<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F01%2FiOS%E4%B8%AD%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[title: iOS中代理使用date: 2018-03-01 10:37:51categories: iOS开发copyright: truetags: iOS 定义一份代理协议 协议名称的格式一般是：类名＋Delegate 比如UITableViewDelegate 设计代理的细节 一般都是@optional(让代理可以有选择的实现一些代理方法) 方法名一般都以类名开头 比如- (void)scrollViewDidScroll: 一般都需要将对象本身传出去 比如tableview的代理方法都会把tableview本身传出去 必须要遵守NSObject协议(基协议) 比如@protocol CellDelegate &lt;NSObject&gt; 声明一个代理属性 代理的类型格式:id &lt;协议&gt; delegate 1@property (nonatomic,weak) id&lt;CellDelegate&gt; delegate; 设置代理对象 代理对象遵守协议，实现协议里面相应的方法 当控件内部发生一些事情，就可以调用代理的代理方法通知代理 如果代理方法是@optional,那么需要判断方法是否有实现，直接调用可能会报错 123if ([self.delegate respondsToSelector:@selector(wineCellDidClickPlusButton:)]) &#123; [self.delegate wineCellDidClickPlusButton:self];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS中的通知NSNotificationCenter]]></title>
    <url>%2F2018%2F03%2F01%2FiOS%E4%B8%AD%E7%9A%84%E9%80%9A%E7%9F%A5NSNotificationCenter%2F</url>
    <content type="text"><![CDATA[通知中心(NSNotificationCenter)是在程序内部提供的一种广播机制。把接收到的消息，根据内部的消息转发表，将消息转发给需要的对象。 通知使用分为两步，第一步：在需要使用的地方注册要观察的通知，第二部：在某地方发送通知。(发送的通知可以是我们自定义的通知，也可以是系统的通知) 如下demo Person.h 123456789101112131415//// Person.h// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *name;@end ​ Person.m 123456789101112131415161718//// Person.m// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import "Person.h"@implementation Person-(void)getNew:(NSNotification *)note&#123; NSLog(@"%@接收到了%@发布的%@通知,通知内容是%@",self.name,[note.object name],note.name,note.userInfo);&#125;@end Company.h 123456789101112131415//// Company.h// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Company : NSObject@property (nonatomic,copy) NSString *name;@end Company.m 12345678910111213//// Company.m// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import "Company.h"@implementation Company@end ViewController.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// ViewController.m// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Person.h"#import "Company.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Company *com1 = [[Company alloc]init]; com1.name = @"Tencent"; Company *com2 = [[Company alloc]init]; com2.name = @"Sina"; Person *p1 = [[Person alloc]init]; p1.name = @"张三"; Person *p2 = [[Person alloc]init]; p2.name = @"李四"; Person *p3 = [[Person alloc]init]; p3.name = @"王五"; /***模拟通知**/ //监听通知 [[NSNotificationCenter defaultCenter] addObserver:p1 selector:@selector(getNew:) name:nil object:nil]; //发布通知 NSNotification *note = [NSNotification notificationWithName:@"军事新闻" object:com1 userInfo:@&#123;@"title":@"xxxxxxx"&#125;]; [[NSNotificationCenter defaultCenter] postNotification:note]; //移除通知 [[NSNotificationCenter defaultCenter]removeObserver:p1];&#125;@end 首先p1张三注册监听，它监听的通知name和object为nil说明它可以监听任何对象发布的任意通知,然后com1发布了一条名称为军事新闻内容为xxxxxxx的通知，张三一旦监听到这条通知就会执行getNew这个方法，这个方法携带了通知的发布者，通知的名称通知的内容等信息。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView]]></title>
    <url>%2F2018%2F01%2F29%2FUITableView%2F</url>
    <content type="text"><![CDATA[简介从字面可以看出它是一个表格UI控件，在iOS开发中UITableView可以说是使用最广泛的控件，我们在使用软件中到处可以看到它的影子，例如QQ以及微信的联系人界面都是UITableView. UITableView有两种显示风格，一个是分组样式，一个是不分组样式。如下图 不分组样式 分组样式 可以看到在UITableView中数据只有行的概念，并没有列的概念，因为在手机操作中显示列是不利于操作的。 UITableView中每行数据都是一个UITableViewCell在这个控件中为了显示更多的信息，iOS已经在其内部设置了多个子控件供使用。一个contentView座位其他元素的父控件，两个UILabel控件（textLabel,detailTextLabel）,一个imageView，分别用于容器、显示内容、详情和图片。 这些控件不一定要全部使用，具体操作时可以通过UITableViewCellStyle进行设置，它是一个枚举表示UITableView的排列方式。 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 左侧显示textLabel（不显示detailTextLabel），imageView可选（显示在最左边） UITableViewCellStyleValue1, // 左侧显示textLabel、右侧显示detailTextLabel（默认蓝色），imageView可选（显示在最左边） UITableViewCellStyleValue2, // 左侧依次显示textLabel(默认蓝色)和detailTextLabel，imageView可选（显示在最左边） UITableViewCellStyleSubtitle // 左上方显示textLabel，左下方显示detailTextLabel（默认灰色）,imageView可选（显示在最左边）&#125;; 数据源由于iOS是遵循MVC模式设计的，很多操作都是通过代理和外界沟通的，但对于数据源控件除了代理还有一个数据源属性，通过它和外界进行数据交互。 对于UITableView设置完dataSource后需要实现UITableViewDataSource协议，在这个协议中定义了多种 数据操作方法。 简单示例 新建一个person模型类 person.h 12345678910111213141516171819202122//// Person.h// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *firstName;@property (nonatomic,copy) NSString *lastName;@property (nonatomic,copy) NSString *phoneNumber;- (Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber;- (NSString *)getName;+ (Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber;@end person.m 1234567891011121314151617181920212223242526272829303132//// Person.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "Person.h"@implementation Person-(Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber&#123; if (self=[super init]) &#123; self.firstName = firstName; self.lastName = lastName; self.phoneNumber = phoneNumber; &#125; return self;&#125;-(NSString *)getName&#123; return [NSString stringWithFormat:@"%@-%@",_lastName,_firstName];&#125;+(Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber&#123; return [[self alloc]initWithFirstName:firstName andLastName:lastName andPhoneNumber:phoneNumber];&#125;@end 新建PersonGroup模型类 PersonGroup.h 123456789101112131415161718192021//// PersonGroup.h// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface PersonGroup : NSObject@property (nonatomic,copy) NSString *name;@property (nonatomic,copy) NSString *detail;@property (nonatomic,strong) NSMutableArray *persons;-(PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons;+(PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons;@end PersonGroup.m 123456789101112131415161718192021222324252627//// PersonGroup.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "PersonGroup.h"@implementation PersonGroup- (PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons&#123; if (self=[super init]) &#123; self.name = name; self.detail = detail; self.persons = persons; &#125; return self;&#125;+ (PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons&#123; return [[self alloc]initWithName:name andDetail:detail andPerson:persons];&#125;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//// ViewController.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Person.h"#import "PersonGroup.h"@interface ViewController ()&lt;UITableViewDataSource&gt;&#123; UITableView *_tableView; NSMutableArray *_persondata;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self initPersonData]; //创建一个分组样式的tableview _tableView = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStyleGrouped]; //设置数据源 _tableView.dataSource = self; [self.view addSubview:_tableView];&#125;/** 加载数据 */- (void)initPersonData&#123; _persondata = [[NSMutableArray alloc]init]; Person *peron1 = [Person initWithFirstName:@"zhang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron2 = [Person initWithFirstName:@"zhang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron3 = [Person initWithFirstName:@"zhang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray1 = [PersonGroup initWithName:@"Z" andDetail:@"张姓" andPersons:[NSMutableArray arrayWithObjects:peron1,peron2,peron3, nil]]; [_persondata addObject:pArray1]; Person *peron4 = [Person initWithFirstName:@"li" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron5 = [Person initWithFirstName:@"li" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron6 = [Person initWithFirstName:@"li" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray2 = [PersonGroup initWithName:@"L" andDetail:@"李姓" andPersons:[NSMutableArray arrayWithObjects:peron4,peron5,peron6, nil]]; [_persondata addObject:pArray2]; Person *peron7 = [Person initWithFirstName:@"wang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron8 = [Person initWithFirstName:@"wang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron9 = [Person initWithFirstName:@"wang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray3 = [PersonGroup initWithName:@"W" andDetail:@"王姓" andPersons:[NSMutableArray arrayWithObjects:peron7,peron8,peron9, nil]]; [_persondata addObject:pArray3];&#125;#pragma mark 数据源方法/** @return 共多少组 */- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return _persondata.count;&#125;/** @param section 那一组 @return 多少行 */- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.persons.count;&#125;/**设置每一行cell数据 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; UITableViewCell *cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil]; cell.textLabel.text = [person getName]; cell.detailTextLabel.text = person.phoneNumber; return cell;&#125;/** @return 每一组的头标题 */-(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.name;&#125;/** @return 每一组的尾标题 */- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.detail;&#125;/** 每组的标题索引 */- (NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; NSMutableArray *indexs = [[NSMutableArray alloc]init]; for (PersonGroup *group in _persondata) &#123; [indexs addObject:group.name]; &#125; return indexs;&#125;@end 运行结果 ​ 方法执行顺序为计算分组数(不写此方法默认为1组)—&gt;计算每组的行数—&gt;生成分组索引—&gt;生成单元格(依次生成所有组的单元格)，生成单元格并不是一次全部生成，而是只会生成显示在界面上的单元格。 代理 设置行高 123456789101112131415161718#pragma mark - 代理方法#pragma mark 设置分组标题内容高度-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; if(section==0)&#123; return 50; &#125; return 40;&#125;#pragma mark 设置每行高度（每行高度可以不一样）-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 45;&#125;#pragma mark 设置尾部说明内容高度-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 40;&#125; 监听点击事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//// ViewController.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Person.h"#import "PersonGroup.h"@interface ViewController ()&lt;UITableViewDataSource,UITableViewDelegate,UIAlertViewDelegate&gt;&#123; UITableView *_tableView; NSMutableArray *_persondata; NSIndexPath *_selectIndexPath;//当前选中的组和行&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self initPersonData]; //创建一个分组样式的tableview _tableView = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStyleGrouped]; //设置数据源 _tableView.dataSource = self; _tableView.delegate = self; [self.view addSubview:_tableView];&#125;/** 加载数据 */- (void)initPersonData&#123; _persondata = [[NSMutableArray alloc]init]; Person *peron1 = [Person initWithFirstName:@"zhang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron2 = [Person initWithFirstName:@"zhang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron3 = [Person initWithFirstName:@"zhang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray1 = [PersonGroup initWithName:@"Z" andDetail:@"张姓" andPersons:[NSMutableArray arrayWithObjects:peron1,peron2,peron3, nil]]; [_persondata addObject:pArray1]; Person *peron4 = [Person initWithFirstName:@"li" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron5 = [Person initWithFirstName:@"li" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron6 = [Person initWithFirstName:@"li" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray2 = [PersonGroup initWithName:@"L" andDetail:@"李姓" andPersons:[NSMutableArray arrayWithObjects:peron4,peron5,peron6, nil]]; [_persondata addObject:pArray2]; Person *peron7 = [Person initWithFirstName:@"wang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron8 = [Person initWithFirstName:@"wang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron9 = [Person initWithFirstName:@"wang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray3 = [PersonGroup initWithName:@"W" andDetail:@"王姓" andPersons:[NSMutableArray arrayWithObjects:peron7,peron8,peron9, nil]]; [_persondata addObject:pArray3];&#125;#pragma mark 数据源方法/** @return 共多少组 */- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return _persondata.count;&#125;/** @param section 那一组 @return 多少行 */- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.persons.count;&#125;/**设置每一行cell数据 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; UITableViewCell *cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil]; cell.textLabel.text = [person getName]; cell.detailTextLabel.text = person.phoneNumber; return cell;&#125;/** @return 每一组的头标题 */-(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.name;&#125;/** @return 每一组的尾标题 */- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.detail;&#125;/** 每组的标题索引 */- (NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; NSMutableArray *indexs = [[NSMutableArray alloc]init]; for (PersonGroup *group in _persondata) &#123; [indexs addObject:group.name]; &#125; return indexs;&#125;#pragma mark 代理方法- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; if (section==0) &#123; return 50; &#125; return 40;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 45;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 40;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; _selectIndexPath = indexPath; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; //创建弹出窗口 UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"窗口标题" message:[person getName] delegate:self cancelButtonTitle:@"完成" otherButtonTitles:@"OK", nil]; alert.alertViewStyle = UIAlertViewStylePlainTextInput;//设置窗口内容样式 UITextField *textField = [alert textFieldAtIndex:0];//取得文本框 textField.text = person.phoneNumber;//设置文本框内容为电话 [alert show];//显示弹出窗口&#125;#pragma mark alert代理方法- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //当点击了第二个按钮（OK） if (buttonIndex==1) &#123; UITextField *textField = [alertView textFieldAtIndex:0]; //修改模型数据 PersonGroup *group = _persondata[_selectIndexPath.section]; Person *person = group.persons[_selectIndexPath.row]; person.phoneNumber = textField.text; //[_tableView reloadData];//刷新表格 这种方式不可取需要局部刷新 NSArray *indexPaths=@[_selectIndexPath];//需要刷新的单元格的组、行 [_tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationLeft];//最后一个参数代表更新时使用那种动画 &#125;&#125;@end 注意修改数据后刷新表格尽量使用局部刷新 性能优化UITableView中的单元格cell时再显示到用户可视区域后创建的，那么如果用户往下滚动就会继续创建显示在屏幕上的单元格，如果用户向上滚动返回到查看过的内容时同样会创建之前已经创建过的单元格，如此一来即使UITableView的内容不是太多，如果用户反复的上下滚动，内存也会瞬间飙升，更何况很多时候UITableView的内容是很多的。 无限滚动UIScrollView是利用有限的UIImageView动态切换其内容来尽可能减少资源占用。同样的，在UITableView中也可以采用类似的方式，只是这时我们不是在滚动到指定位置后更改滚动的位置而是要将当前没有显示的Cell重新显示在将要显示的Cell的位置然后更新其内容。原因就是UITableView中的Cell结构布局可能是不同的，通过重新定位是不可取的，而是需要重用已经不再界面显示的已创建过的Cell. UITableView内部有一个缓存池，初始化的时候使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString \*)方法指定一个可重用表示，就可以将这个cell放到缓存池。然后在使用的时候使用指定的标识符取缓存池中取得对应的cell然后修改cell内容即可。 123456789101112131415161718192021/**设置每一行cell数据 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; //方法调用十分频繁，声明成静态变量有利于性能优化 static NSString *ID = @"person"; //先从缓存中取标识符为ID的cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; //如果缓存池中没有标识符为ID的cell再新建一个标识符为ID的cell if (cell==nil) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; &#125; cell.textLabel.text = [person getName]; cell.detailTextLabel.text = person.phoneNumber; return cell;&#125; 自定义TableViewCell(仿照微博)文件结构图 创建微博模型类 Status.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//// Status.h// 自定义不等高cell//// Created by 武 on 18/1/25.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface Status : NSObject/** 图像 */@property (nonatomic,copy) NSString *icon;/** 昵称 */@property (nonatomic,copy) NSString *name;/** 正文内容 */@property (nonatomic,copy) NSString *text;/** VIP */@property (nonatomic,assign,getter=isVip) BOOL vip;/** 配图 */@property (nonatomic,copy) NSString *picture;/** 图像的frame */@property (nonatomic,assign) CGRect iconFrame;/** 昵称的frame */@property (nonatomic,assign) CGRect nameFrame;/** vip的frame */@property (nonatomic,assign) CGRect vipFrame;/** 正文frame */@property (nonatomic,assign) CGRect textFrame;/** 配图的frame */@property (nonatomic,assign) CGRect pictureFrame;/** cell的高度 */@property (nonatomic,assign) CGFloat cellHeight;@end Status.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//// Status.m// 自定义不等高cell//// Created by 武 on 18/1/25.// Copyright © 2018年 com. All rights reserved.//#import "Status.h"@implementation Status-(CGFloat)cellHeight&#123; if (_cellHeight == 0 ) &#123; CGFloat space = 10; //图像 CGFloat iconX = space; CGFloat iconY = space; CGFloat iconWH = 30; self.iconFrame = CGRectMake(iconX, iconY, iconWH, iconWH); //昵称 CGFloat nameX = CGRectGetMaxX(self.iconFrame)+space; CGFloat nameY = iconY; NSDictionary *nameAtt = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:17]&#125;; //计算昵称文字的尺寸 CGSize nameSize = [self.name sizeWithAttributes:nameAtt]; CGFloat nameW = nameSize.width; CGFloat nameH = nameSize.height; self.nameFrame = CGRectMake(nameX, nameY, nameW, nameH); //vip if (self.isVip) &#123; CGFloat vipX = CGRectGetMaxX(self.nameFrame)+space; CGFloat vipW = 14; CGFloat vipH = nameH; CGFloat vipY = nameY; self.vipFrame = CGRectMake(vipX, vipY, vipW, vipH); &#125; //正文 CGFloat textX = iconX; CGFloat textY = CGRectGetMaxY(self.iconFrame)+space; CGFloat textW = [UIScreen mainScreen].bounds.size.width-2*space; NSDictionary *textAtt = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125;; //最大宽度是textW,宽度不限制 CGSize textSize = CGSizeMake(textW, MAXFLOAT); CGFloat textH = [self.text boundingRectWithSize:textSize options:NSStringDrawingUsesLineFragmentOrigin attributes:textAtt context:nil].size.height; self.textFrame = CGRectMake(textX, textY, textW, textH); //配图 if (self.picture) &#123; CGFloat pictureWH = 100; CGFloat pictureX = iconX; CGFloat pictureY = CGRectGetMaxY(self.textFrame)+space; self.pictureFrame = CGRectMake(pictureX, pictureY, pictureWH, pictureWH); _cellHeight = CGRectGetMaxY(self.pictureFrame)+space; &#125;else &#123; _cellHeight = CGRectGetMaxY(self.textFrame)+space; &#125; &#125; return _cellHeight;&#125;@end ​ 自定义cell必须继承UITableViewCell类 StatusCell.h 123456789101112131415//// StatusCell.h// 自定义不等高cell//// Created by 武 on 18/1/26.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@class Status;@interface StatusCell : UITableViewCell/** 微博模型 */@property (nonatomic,strong) Status *status;@end StatusCell.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// StatusCell.m// 自定义不等高cell//// Created by 武 on 18/1/26.// Copyright © 2018年 com. All rights reserved.//#import "StatusCell.h"#import "Status.h"@interface StatusCell()/** 图像 */@property (nonatomic,weak) UIImageView *iconImageView;/** 昵称 */@property (nonatomic,weak) UILabel *nameLabel;/** vip */@property (nonatomic,weak) UIImageView *vipImageView;/** 正文 */@property (nonatomic,weak) UILabel *text_Label;/** 配图 */@property (nonatomic,weak) UIImageView *pictureImageView;@end@implementation StatusCell/** 添加子控件的原则：把所有可能显示的子控件都先添加进去 */-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; //图像 UIImageView *iconImageView = [[UIImageView alloc]init]; [self.contentView addSubview:iconImageView]; self.iconImageView = iconImageView; //配图 UIImageView *pictureImageView = [[UIImageView alloc]init]; [self.contentView addSubview:pictureImageView]; self.pictureImageView = pictureImageView; //vip UIImageView *vipImageView = [[UIImageView alloc]init]; vipImageView.contentMode = UIViewContentModeCenter; vipImageView.image = [UIImage imageNamed:@"vip"]; [self.contentView addSubview:vipImageView]; self.vipImageView = vipImageView; //昵称 UILabel *nameLabel = [[UILabel alloc]init]; nameLabel.font = [UIFont systemFontOfSize:14]; [self.contentView addSubview:nameLabel]; self.nameLabel = nameLabel; //正文 UILabel *text_Label = [[UILabel alloc]init]; text_Label.font = [UIFont systemFontOfSize:14]; text_Label.numberOfLines = 0; [self.contentView addSubview:text_Label]; self.text_Label = text_Label; &#125; return self;&#125;/* 设置子控件的数据 */- (void)setStatus:(Status *)status&#123; _status = status; self.iconImageView.image = [UIImage imageNamed:status.icon]; self.nameLabel.text = status.name; if (status.isVip) &#123; self.nameLabel.textColor = [UIColor orangeColor]; self.vipImageView.hidden = NO; &#125;else &#123; self.vipImageView.hidden = YES; self.nameLabel.textColor = [UIColor blackColor]; &#125; self.text_Label.text = status.text; if (status.picture) &#123; self.pictureImageView.hidden = NO; self.pictureImageView.image = [UIImage imageNamed:status.picture]; &#125;else &#123; self.pictureImageView.hidden = YES; &#125; self.iconImageView.frame = self.status.iconFrame; self.nameLabel.frame = self.status.nameFrame; self.vipImageView.frame = self.status.vipFrame; self.text_Label.frame = self.status.textFrame; self.pictureImageView.frame = self.status.pictureFrame;&#125;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// ViewController.m// 自定义不等高cell//// Created by 武 on 18/1/25.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Status.h"#import "MJExtension.h"#import "StatusCell.h"@interface ViewController ()@property (nonatomic,strong) NSArray *statues;@end@implementation ViewController-(NSArray *)statues&#123; if (_statues==nil) &#123; _statues = [Status mj_objectArrayWithFilename:@"statuses.plist"]; &#125; return _statues;&#125;NSString *ID = @"status";- (void)viewDidLoad &#123; [super viewDidLoad]; //注册cell [self.tableView registerClass:[StatusCell class] forCellReuseIdentifier:ID];&#125;#pragma mark 数据源方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.statues.count;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; StatusCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; cell.status = self.statues[indexPath.row]; return cell;&#125;#pragma mark 代理方法- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; Status *status = self.statues[indexPath.row]; return status.cellHeight;&#125;- (BOOL)prefersStatusBarHidden&#123; return YES;&#125;@end TableView数据刷新 UITableView的刷新方法 12345 (void)reloadData;//刷新整个表格。- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);//刷新指定的分组和行。- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);//刷新指定的分组。- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//删除时刷新指定的行数据。- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//添加时刷新指定的行数据。 全局刷新 示例说明在Main.storyboard中添加一个UIView里面包含3个按钮分别是添加、更新、删除。下面再添加一个TableView。 如下图 模型类Wine.h 12345678910111213141516171819202122//// Wine.h// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Wine : NSObject/** 图标 */@property (nonatomic,copy) NSString *image;/** 价格 */@property (nonatomic,copy) NSString *money;/** 名称 */@property (nonatomic,copy) NSString *name;@end 自定义cell-WineCell.h 12345678910111213141516//// WineCell.h// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@class Wine;@interface WineCell : UITableViewCell/** 模型属性 */@property (nonatomic,strong) Wine *wine;@end WineCell.m 12345678910111213141516171819//// WineCell.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "WineCell.h"#import "Wine.h"@implementation WineCell-(void)setWine:(Wine *)wine&#123; _wine = wine; self.textLabel.text = wine.name; self.imageView.image = [UIImage imageNamed:wine.image]; self.detailTextLabel.text = [NSString stringWithFormat:@"¥%@",wine.money];&#125;@end ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// ViewController.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "MJExtension.h"#import "Wine.h"#import "WineCell.h"@interface ViewController ()&lt;UITableViewDataSource&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;/** 所有的数据 */@property (nonatomic,strong)NSMutableArray *wineArray;@end@implementation ViewController/** 从plist文件加载数据，使用MJExtension框架 */-(NSMutableArray *)wineArray&#123; if (_wineArray==nil) &#123; _wineArray = [Wine mj_objectArrayWithFilename:@"wine.plist"]; &#125; return _wineArray;&#125;/** 点击添加 */- (IBAction)add &#123; //新建一个模型 Wine *wine = [[Wine alloc]init]; wine.image = @"newWine"; wine.money = @"999.9"; wine.name = @"茅台"; // [self.wineArray addObject:wine];//添加到表格最后 [self.wineArray insertObject:wine atIndex:0];//添加到表格第一位 //数据发生变化，刷新数据（全局刷新） [self.tableView reloadData];&#125;/** 点击删除 */- (IBAction)delete &#123; // 删除模型 [self.wineArray removeObjectAtIndex:0]; [self.wineArray removeObjectAtIndex:0]; //全局刷新 [self.tableView reloadData];&#125;/** 点击更新 */- (IBAction)update &#123; // 更新模型，把价格改为100 Wine *wine = self.wineArray[0]; wine.money = @"100"; // 全局刷新 [self.tableView reloadData];&#125;#pragma mark 数据源方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.wineArray.count;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @"wine"; WineCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell==nil) &#123; cell = [[WineCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; &#125; cell.wine = _wineArray[indexPath.row]; return cell;&#125;@end 运行如下 局部刷新（操作那一行数据刷新哪一行） 修改add、update、delete三个方法的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (IBAction)add &#123; // 修改模型 XMGWine *wine = [[XMGWine alloc] init]; wine.image = @"newWine"; wine.money = @"56"; wine.name = @"杏花村"; [self.wineArray insertObject:wine atIndex:0]; // 这是全局刷新// [self.tableView reloadData]; // 局部刷新 NSArray *indexPaths = @[ [NSIndexPath indexPathForRow:0 inSection:0] ]; [self.tableView insertRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationRight];&#125;- (IBAction)remove &#123; // 修改模型 [self.wineArray removeObjectAtIndex:0]; [self.wineArray removeObjectAtIndex:0]; // 局部刷新 NSArray *indexPaths = @[ [NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0], ]; [self.tableView deleteRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationMiddle]; // 这是全局刷新// [self.tableView reloadData];&#125;- (IBAction)update &#123; // 修改模型 XMGWine *wine = self.wineArray[0]; wine.money = @"100"; XMGWine *wine2 = self.wineArray[1]; wine2.name = @"呵呵"; // 局部刷新 NSArray *indexPaths = @[ [NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0] ]; [self.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationLeft];&#125; 左滑删除12345678910/** 只要实现这个方法，就拥有左滑删除功能 点击左滑出现的Delete按钮会调用这个 */-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@&quot;commitEditingStyle--&quot;); [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];//局部删除删除&#125; UITableViewRowAction 1234567891011121314//左滑出现什么按钮- (NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewRowAction *action = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;关注&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; self.tableView.editing = NO; &#125;]; UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@&quot;删除&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; &#125;]; return @[action,action1];&#125; 编辑模式12345- (IBAction)remove&#123; //进入编辑模式，点击删除按钮取反 [self.tableView setEditing:!self.tableView.isEditing animated:YES];&#125; 自定义批量删除在cell里面添加一个打勾的UIImageView的控件并设置尺寸该控件选择的时候显示，默认隐藏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// WineCell.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "WineCell.h"#import "Wine.h"@interface WineCell()/** 打钩控件 */@property (nonatomic,weak) UIImageView *checkedImageView;@end@implementation WineCell/** 初始化控件 */- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; //添加打勾控件 UIImageView *checkImageView = [[UIImageView alloc]init]; checkImageView.hidden = YES; checkImageView.image = [UIImage imageNamed:@"check"]; [self.contentView addSubview:checkImageView]; self.checkedImageView = checkImageView; &#125;; return self;&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; //设置打勾控件的位置和尺寸 CGFloat WH = 24; CGFloat X = self.contentView.frame.size.width - WH - 10; CGFloat Y = (self.contentView.frame.size.height-WH)*0.5; self.checkedImageView.frame = CGRectMake(X, Y, WH, WH); //调整cell textLabel的宽度 CGRect frame = self.textLabel.frame; frame.size.width = self.contentView.frame.size.width-WH-20-self.textLabel.frame.origin.x; self.textLabel.frame = frame;&#125;-(void)setWine:(Wine *)wine&#123; _wine = wine; self.textLabel.text = wine.name; self.imageView.image = [UIImage imageNamed:wine.image]; self.detailTextLabel.text = [NSString stringWithFormat:@"¥%@",wine.money]; //根据模型的checked属性确定打勾控件显示还是隐藏 if (wine.isChecked) &#123; self.checkedImageView.hidden = NO; &#125;else &#123; self.checkedImageView.hidden = YES; &#125;&#125;@end 在模型类Wine.h里添加一个BOOL属性记录打勾控件的状态 1234/** 记录打勾控件的状态 */@property (nonatomic,assign,getter=isChecked) BOOL checked; ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// ViewController.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "MJExtension.h"#import "Wine.h"#import "WineCell.h"@interface ViewController ()&lt;UITableViewDataSource,UITableViewDelegate&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;/** 所有的数据 */@property (nonatomic,strong)NSMutableArray *wineArray;/** 记录所有选中行的索引 */@property (nonatomic,strong)NSMutableArray *selectedIndexPath;@end@implementation ViewController- (NSMutableArray *)selectedIndexPath&#123; if (!_selectedIndexPath) &#123; _selectedIndexPath = [NSMutableArray array]; &#125; return _selectedIndexPath;&#125;- (IBAction)remove &#123; //进入编辑模式，点击删除按钮取反 //[self.tableView setEditing:!self.tableView.isEditing animated:YES]; //获取要删除的所有模型 NSMutableArray *deleteWine = [NSMutableArray array]; for (NSIndexPath *indexPath in self.selectedIndexPath) &#123; [deleteWine addObject:self.wineArray[indexPath.row]]; &#125; //删除模型 [self.wineArray removeObjectsInArray:deleteWine]; //刷新表格 [self.tableView deleteRowsAtIndexPaths:self.selectedIndexPath withRowAnimation:UITableViewRowAnimationAutomatic]; //注意操作一次必须清空数组，要不然会数组角标越界 [self.selectedIndexPath removeAllObjects];&#125;/** 从plist文件加载数据，使用MJExtension框架 */-(NSMutableArray *)wineArray&#123; if (_wineArray==nil) &#123; _wineArray = [Wine mj_objectArrayWithFilename:@"wine.plist"]; &#125; return _wineArray;&#125; #pragma mark 数据源方法 (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return self.wineArray.count;} -(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ static NSString *ID = @&quot;wine&quot;; WineCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell==nil) { cell = [[WineCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; } cell.wine = _wineArray[indexPath.row]; return cell; } #pragma mark - 代理方法/* 只要实现这个方法，就拥有左滑删除功能 点击左滑出现的Delete按钮会调用这个 /-(void)tableView:(UITableView )tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath )indexPath{ NSLog(@&quot;commitEditingStyle--&quot;); [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];//局部删除删除 } (NSArray )tableView:(UITableView )tableView editActionsForRowAtIndexPath:(NSIndexPath )indexPath{ UITableViewRowAction action = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@”关注” handler:^(UITableViewRowAction _Nonnull action, NSIndexPath _Nonnull indexPath) { self.tableView.editing = NO; }]; UITableViewRowAction action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@”删除” handler:^(UITableViewRowAction _Nonnull action, NSIndexPath * _Nonnull indexPath) { [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; }]; return @[action,action1];}//选择那一行的操作 (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath{ //修改模型 Wine *wine = self.wineArray[indexPath.row]; if (wine.isChecked) {//之前是打勾的就取反 wine.checked = NO; [self.selectedIndexPath removeObject:indexPath]; }else {//之前不是打勾的，现在打勾 wine.checked = YES; [self.selectedIndexPath addObject:indexPath]; } //局部刷新表格 [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];}@end``` 运行效果 ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView]]></title>
    <url>%2F2018%2F01%2F29%2FUIScrollView%2F</url>
    <content type="text"><![CDATA[简介UIScrollView是UIView的子类，这是一个可以处理滚动操作的UI控件在开发过程中使用很频繁。 属性123456789101112131415@property(nonatomic) CGPoint contentOffset;//内容偏移量，当前显示的内容得顶点相对此控件顶点x,y轴之间的距离，默认为CGPointZero@property(nonatomic) CGSize contentSize;//控件内容大小，不一定在显示区域，如果这个属性不设置，此控件将无法滚动，默认为CGSizeZero;@property(nonatomic) UIEdgeInsets contentInset;//控件四周边距，类似于css中的margin，注意边距不座位其内容的一部分，默认为UIEdgeInsertZero;@property(nonatomic,assign) id&lt;UIScrollViewDelegate&gt; delegate; //控件代理，一般用于事件监听，在iOS中多数控件都是通过代理来进行事件监听的@property(nonatomic) BOOL bounces;//启用弹簧效果，启用弹簧效果后拖动到边缘可以看到内容后面的背景，默认设置为YES@property(nonatomic,getter=isPagingEnabled)BOOL pagingEnabled;//是否分页，如果分页的话每次左右拖动的距离只屏幕宽度的整倍数，默认设置为NO@property(nonatomic,getter=isScrollEnabled)BOOL scrollEnabled;//是否启用滚动，默认也YES@property(nonatomic) BOOL showsHorizontalScrollIndicator;//是否显示横向滚动条，默认为YES@property(nonatomic) BOOL showsVerticalScrollIndicator;//是否显示纵向滚动条，默认为YES@property(nonatomic) CGFloat minimumZoomScale;//最小缩放倍数，默认为1.0@property(nonatomic) CGFloat maximumZoomScale;//最大缩放倍数(注意只有maximumZoomScale大于minimumZoomScale才有可能缩放)默认为1.0@property(nonatomic,readonly,getter= isTracking)BOOL tracking;//状态是否被追踪，手指按下去并且还没有拖动的时候是YES，其他情况均为NO@property(nonatomic,readonly,getter= isDragging)BOOL dragging;//判断状态是否被拖拽@property(nonatomic,readonly,getter=isDecelerating)BOOL decelerating;//判断状态是否减速@property(nonatomic,readonly,getter=isZomming)BOOL zomming;//判断状态是否缩放 方法12- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;//设置滚动位置，第二个参数表示是否启用动画效果- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;//滚动并显示指定区域的内容，第二个参数表示是否启用动画效果 代理方法12345678- (void)scrollViewDidScroll:(UIScrollView *)scrollView;//滚动事件方法，滚动过程中会一直循环执行- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;//开始拖拽事件- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;//拖拽操作完成事件方法- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;//即将停止滚动事件方法（拖拽松开后开始减速时执行）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;//滚动停止事件方法（滚动过程中减速停止后执行）- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view NS_AVAILABLE_IOS(3_2);//开始缩放事件方法- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2);//缩放操作完成事件方法- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;//返回缩放视图，注意只有实现这个代理方法才能进行缩放，此方法返回需要缩放的视图 简单示例 ViewController.h 1234567891011121314//// ViewController.h// UIScrollView-1//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController @property (nonatomic,strong) UIScrollView *scrollview;@property (nonatomic,strong) UIImageView *imageView;@end ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//// ViewController.m// UIScrollView-1//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"//实现UIScrollView代理@interface ViewController ()&lt;UIScrollViewDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //添加scrollview控件 //注意UIScreen代表当前屏幕对象，applicationFrame是当前屏幕内容区域 _scrollview = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].applicationFrame]; _scrollview.contentMode = UIViewContentModeScaleToFill; [self.view addSubview:_scrollview]; //添加图片控件 UIImage *image = [UIImage imageNamed:@"timg"]; _imageView = [[UIImageView alloc]initWithImage:image]; [_scrollview addSubview:_imageView]; //contentSize必须设置，否则无法滚动，当前设置为图片大小 _scrollview.contentSize = _imageView.frame.size; //实现缩放：maxinumZoomScale必须大于minimumZoomScale同时实现viewForZoomingInScrollView方法 _scrollview.minimumZoomScale = 0.6; _scrollview.maximumZoomScale = 3.0; //设置代理为viewController _scrollview.delegate = self; //边距，不属于内容部分，内容坐标（0，0）指的是内容的左上角不包括边界 //_scrollView.contentInset=UIEdgeInsetsMake(10, 20, 10, 20); //显示滚动内容的指定位置 //_scrollView.contentOffset=CGPointMake(10, 0); //隐藏滚动条 _scrollview.showsHorizontalScrollIndicator = NO; _scrollview.showsVerticalScrollIndicator = NO; //禁用弹簧效果 //_scrollView.bounces=NO;&#125;#pragma mark 代理方法- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; return _imageView;&#125;- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewWillBeginDecelerating");&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewDidEndDecelerating");&#125;-(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewWillBeginDragging");&#125;-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@"scrollViewDidEndDragging");&#125;-(void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view&#123; NSLog(@"scrollViewWillBeginZooming");&#125;-(void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale&#123; NSLog(@"scrollViewDidEndZooming");&#125;#pragma mark 当图片小于屏幕宽高时缩放后让图片显示到屏幕中间- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; CGSize originalSize = _scrollview.bounds.size; CGSize contentSize = _scrollview.contentSize; //计算偏移量X轴 CGFloat offSetx = originalSize.width&gt;contentSize.width?(originalSize.width-contentSize.width)/2:0; //计算偏移量Y轴 CGFloat offSetY = originalSize.height&gt;contentSize.height?(originalSize.height-contentSize.height)/2:0; _imageView.center = CGPointMake(contentSize.width/2+offSetx, contentSize.height/2+offSetY);&#125;@end 效果如下图 ​ UIScrollView实战-实现无限循环 说明 如何无限循环一种是无限循环叠加图片，另一种就是如果最后一张图片浏览完立即显示第一张图片。很明显第一种方法是不现实的，使用第二种方式。其实使用第二种方式实现原理比较简单，只要在图片前后各放一张图片即可（此时共有n+2个图片在UIScrollView中）。例如我们有5张图片，只要使用7个UIImageView依次存放：图片5，图片1，图片2，图片3，图片4，图片5，图片1。当从图片1滚动到图片5时由于最后一张是图片1就给用户一种无限循环的感觉，当这张图完全显示后我们迅速将UIScrollView的contentOffset设置到第二个UIImageView，也就是图片1，接着用户可以继续向后滚动。当然向前滚动原理完全一样，当滚动到第一张图片（图片5）就迅速设置UIScrollView的contentOffset显示第6张图（图片5）。 如何优化性能如果图片过多这些图片势必全部加载到内存消耗很大，其实完全没必要创建n+2个UIImageView，其实3个已经足够，只要一直保持显示中间的UIImageView，滚动时动态更改三个UIImageView的图片即可。例如三个UIImageView默认放图片5、图片1、图片2，当前显示中间的UIImageView，也就是图片1,。如果向后滚动那么就会显示图片2，当图片2显示完整后迅速重新设置三个UIImageView的内容为图片1、图片2、图片3，然后通过contentOffset设置显示中间的UIImageView，也就是图片2。继续向后看到图片3，当图片3滚动完成迅速重新设置3个UIImageView的内容为图片2、图片3、图片4，然后设置contentOffset显示中间的UIImageView，也就是图片3。当然，向前滚动原理完全一样，如此就给用户一种循环错觉，而且不占用过多内存。 通过解析plist文件来加载图片数据 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;0.jpg&lt;/key&gt; &lt;string&gt;图0&lt;/string&gt; &lt;key&gt;1.jpg&lt;/key&gt; &lt;string&gt;图1&lt;/string&gt; &lt;key&gt;2.jpg&lt;/key&gt; &lt;string&gt;图2&lt;/string&gt; &lt;key&gt;3.jpg&lt;/key&gt; &lt;string&gt;图3&lt;/string&gt; &lt;key&gt;4.jpg&lt;/key&gt; &lt;string&gt;图4&lt;/string&gt; &lt;key&gt;5.jpg&lt;/key&gt; &lt;string&gt;图5&lt;/string&gt; &lt;key&gt;6.jpg&lt;/key&gt; &lt;string&gt;图6&lt;/string&gt; &lt;key&gt;7.jpg&lt;/key&gt; &lt;string&gt;图7&lt;/string&gt; &lt;key&gt;8.jpg&lt;/key&gt; &lt;string&gt;图8&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//// ViewController.m// 无限滚动图片//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#define SCREEN_WIDTH 320#define SCREEN_HEIGHT 568#define IMAGEVIEW_COUNT 3@interface ViewController ()&lt;UIScrollViewDelegate&gt;&#123; UIScrollView *_scrollView; UIImageView *_leftImageView; UIImageView *_centerImageView; UIImageView *_rightImageView; UIPageControl *_pageControl; UILabel *_label; NSMutableDictionary *_imageData;//图片数据 int _currentImageIndex;//当前图片索引 int _imageCount;//图片总数&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self loadImageData]; //添加滚动控件 [self addScrollView]; //添加图片控件 [self addImageViews]; //添加分页控件 [self addPageControl]; //添加图片信息描述控件 [self addLabel]; //加载默认图片 [self setDefaultImage];&#125;#pragma mark 加载图片数据- (void)loadImageData&#123; NSString *path = [[NSBundle mainBundle]pathForResource:@"imageInfo" ofType:@"plist"]; _imageData = [NSMutableDictionary dictionaryWithContentsOfFile:path]; _imageCount = _imageData.count;&#125;#pragma mark 添加控件- (void)addScrollView&#123; _scrollView = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].bounds]; [self.view addSubview:_scrollView]; //设置代理 _scrollView.delegate = self; //设置contentSize _scrollView.contentSize = CGSizeMake(IMAGEVIEW_COUNT*SCREEN_WIDTH, SCREEN_HEIGHT); //设置当前显示的位置为中间图片 [_scrollView setContentOffset:CGPointMake(SCREEN_WIDTH, 0) animated:NO]; //设置分页 _scrollView.pagingEnabled=YES; //去掉滚动条 _scrollView.showsHorizontalScrollIndicator=NO;&#125;#pragma mark 添加图片三个控件-(void)addImageViews&#123; _leftImageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _leftImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_leftImageView]; _centerImageView=[[UIImageView alloc]initWithFrame:CGRectMake(SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _centerImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_centerImageView]; _rightImageView=[[UIImageView alloc]initWithFrame:CGRectMake(2*SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _rightImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_rightImageView]; &#125;#pragma mark 设置默认显示图片-(void)setDefaultImage&#123; //加载默认图片 _leftImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",_imageCount-1]]; _centerImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",0]]; _rightImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",1]]; _currentImageIndex=0; //设置当前页 _pageControl.currentPage=_currentImageIndex; NSString *imageName=[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]; _label.text=_imageData[imageName];&#125;#pragma mark 添加分页控件-(void)addPageControl&#123; _pageControl=[[UIPageControl alloc]init]; //注意此方法可以根据页数返回UIPageControl合适的大小 CGSize size= [_pageControl sizeForNumberOfPages:_imageCount]; _pageControl.bounds=CGRectMake(0, 0, size.width, size.height); _pageControl.center=CGPointMake(SCREEN_WIDTH/2, SCREEN_HEIGHT-100); //设置颜色 _pageControl.pageIndicatorTintColor=[UIColor colorWithRed:193/255.0 green:219/255.0 blue:249/255.0 alpha:1]; //设置当前页颜色 _pageControl.currentPageIndicatorTintColor=[UIColor colorWithRed:0 green:150/255.0 blue:1 alpha:1]; //设置总页数 _pageControl.numberOfPages=_imageCount; [self.view addSubview:_pageControl];&#125;#pragma mark 添加信息描述控件-(void)addLabel&#123; _label=[[UILabel alloc]initWithFrame:CGRectMake(0, 10, SCREEN_WIDTH,30)]; _label.textAlignment=NSTextAlignmentCenter; _label.textColor=[UIColor colorWithRed:0 green:150/255.0 blue:1 alpha:1]; [self.view addSubview:_label];&#125;#pragma mark 滚动停止事件-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; //重新加载图片 [self reloadImage]; //移动到中间 [_scrollView setContentOffset:CGPointMake(SCREEN_WIDTH, 0) animated:NO]; //设置分页 _pageControl.currentPage=_currentImageIndex; //设置描述 NSString *imageName=[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]; _label.text=_imageData[imageName];&#125;#pragma mark 重新加载图片-(void)reloadImage&#123; int leftImageIndex,rightImageIndex; CGPoint offset=[_scrollView contentOffset]; if (offset.x&gt;SCREEN_WIDTH) &#123; //向右滑动 _currentImageIndex=(_currentImageIndex+1)%_imageCount; &#125;else if(offset.x&lt;SCREEN_WIDTH)&#123; //向左滑动 _currentImageIndex=(_currentImageIndex+_imageCount-1)%_imageCount; &#125; //UIImageView *centerImageView=(UIImageView *)[_scrollView viewWithTag:2]; _centerImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]]; //重新设置左右图片 leftImageIndex=(_currentImageIndex+_imageCount-1)%_imageCount; rightImageIndex=(_currentImageIndex+1)%_imageCount; _leftImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",leftImageIndex]]; _rightImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",rightImageIndex]];&#125;@end ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView解析]]></title>
    <url>%2F2018%2F01%2F27%2FUIView%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UIView是管理屏幕上矩形区域内容的对象，iOS中几乎所有UI控件都是UIView的子类。 三个结构体CGPoint、CGSize、CGRect 1.CGPoint 12345struct CGPoint&#123; CGFloat x; //控件x轴位置 CGFLoat y; //控件Y轴位置&#125; CGSize 12345struct CGSize&#123; CGFloat width; //控件宽度 CGFloat height; //控件高度&#125; CGRect 12345struct CGRect&#123; CGPoint origin; //偏移量是相对父视图的 CGSize size;&#125; 视图的基本属性​ frame和center都是相对父视图来说的，bounds是相对自身来说的 frame是相对于父视图左上角原点(0,0)的位置，改变视图的frame会改变center中心点 center是CGPoint值的就是整个视图的中心点，改变视图的center也会改变frame bounds 是CGRect 是告诉子视图本视图的原点位置(通俗的说就是，子视图的frame的origin与父视图的bounds的origin的差，就是子视图相对于父视图左上角的位置，如果结果为负，则子视图在父视图外) 通过addSubview方法添加的子视图，越后添加，越显示到上层。 移除父视图也会把它里面的子视图移除 基本界面元素 1.UIView 1UIView *myView = [[UIView alloc]initWithFrame:CGrectMake(10,10,50,50)];//创建了一个x轴10，y轴10，宽度为50，高度为50的UIView. 2.UIWindow UIWindow继承自UIView，在系统的初始化过程中创建(application didFinishLauchingWithOptions里面) 123self.window = [[[UIWindos alloc]initWithFrame:[UIScreen mainScreen]bounds]autorelease];self.window.backgroundColor = [UIColor grayColor]; //给window设置一个背景色 [self.window makeKeyAndVisible]; //让window显示出来 UIScreen代表了屏幕 12CGRect screenBounds = [ [UIScreen mainScreen]bounds]; //返回的是带有状态栏的Rect CGRect viewBounds = [ [UIScreen mainScreen]applicationFrame]; //不包含状态栏的Rect ​ UIView的方法 一个 UIView 里面可以包含许多的 Subview（其他的 UIView），而这些 Subview 彼此之间是有所谓的阶层关系，这有点类似绘图软体中图层的概念，下面程式码示演示了几个在管理图层（Subview）上常用的方法，其程式码如下。 1.首先是大家最常使用的新增和移除Subview。 ​123[Subview removeFromSuperview]; //将Subview从当前的UIView中移除 [UIView addSubview:Subview]; //UIView增加一个Subview​ 2.在UIView中将Subview往前或是往后移动一个图层，往前移动会覆盖住较后层的 Subview，而往后移动则会被较上层的Subview所覆盖。 123[UIView bringSubviewToFront:Subview]; //将Subview往前移动一个图层（与它的前一个图层对调位置）//将Subview往前移动一个图层（与它的前一个图层对调位置）[UIView sendSubviewToBack:Subview]; //将Subview往后移动一个图层（与它的后一个图层对调位置) 3.在UIView中使用索引Index交换两的Subview彼此的图层层级。 1[UIView exchangeSubviewAtIndex:indexA withSubviewAtIndex:indexB]; //交换两个图层 4.使用Subview的变数名称取得它在UIView中的索引值（Index ） 1NSInteger index = [[UIView subviews] indexOfObject:Subview名称]; //取得Index 5.替Subview加上NSInteger 的註记(Tag)好让之后它们分辨彼此。 12[Subview setTag:NSInteger]; //加上标记 [UIView viewWithTag:NSInteger]; //通过标记得到view 返回值为UIView 6.最后是取得UIView中所有的Subview，呼叫此方法会传回一个 NSArray，并以由后往前的顺序列出这些 Subview，下图中是列出范例图片里Root中所有的Subview。 1[UIView subviews] ; //取的UIView下的所有Subview UIView常用属性和方法 属性 12345678910@property(nonatomic) CGRect frame;//控件的位置和大小，所有的控件必须指定这个属性，否则即使有控件也无法显示@property(nonatomic) CGRect bounds;//当前控件位置和大小，但是和frame不同的是它的位置是确定的(0,0)@property(nonatomic) CGPoint center;//控件的中心位置，一般用户进行控件定位@property(nonatomic) CGAffineTransform transform;//控件矩阵变化，包括平移、缩放、旋转，默认为CGAffineTransformIdentity@property(nonatomic) UIViewAutoresizing autoresizingMask;//控件旋转时大小自动伸缩，默认为UIViewAutoresizingNone@property(nonatomic,readonly) UIView *superview;//当前控件的父控件@property(nonatomic,readonly,copy) NSArray *subviews;//当前控件的子控件返回一个数组@property(nonatomic,getter=isHidden) BOOL hidden;//是否隐藏，默认为不隐藏。@property(nonatomic) UIViewContentMode contentMode; //控件的显示模式。如ImageView的居中模式等@property(nonatomic) NSInteger tag;//控件的标签属性 方法 1234567- (void)addSubview:(UIView *) view;//添加子控件- (void)removeFromSuperView;//从父控件中移除当前控件- (void)insertSubview:(UIView *)view atIndex:(NSInteger) index; //在指定位置插入子控件- (void)beginAnimations:*(NSString *)animationID context:(void *)context;//开始一段动画+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0);//以block的形式执行一段动画，注意这个方法有几种相关的方法- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2); //添加手势操作- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2); //移除手势操作 上面所有位置的属性都是相对于父控件而言（不是相对主屏幕而言） ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS程序启动过程]]></title>
    <url>%2F2018%2F01%2F26%2FiOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[点击程序图标打开程序 执行main函数 执行UIApplicationMain函数 通过UIApplicationMain方法的反射创建UIApplication对象设置代理，开启消息循环 开启监听程序事件 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//程序加载完毕后调用该方法&#125;- (void)applicationWillResignActive:(UIApplication *)application &#123;//程序失去焦点调用该方法&#125;- (void)applicationDidEnterBackground:(UIApplication *)application &#123;//程序进入后台调用该方法&#125;- (void)applicationWillEnterForeground:(UIApplication *)application &#123;//程序从后台将要进入前台调用该方法&#125;- (void)applicationDidBecomeActive:(UIApplication *)application &#123;//内存经过，程序将要停止调用该方法&#125;- (void)applicationWillTerminate:(UIApplication *)application &#123;//程序将要退出调用该方法&#125; 加载info.plist程序配置文件，主要是看我们用的是Storyboard方式加载还是代码的方式加载。 通过storyboard方式加载 在程序启动完成的时候系统自动创建一个UIWindow的实例来显示界面 1@property (strong, nonatomic) UIWindow *window; 设置窗口的根控制器 根据storyboard的设置，创建一个控制器。 并且设置这个控制器为之前创建的UIWindow的根控制器 显示窗口。（makeKeyAndVisible） 设置self.window可见并且设置UIApplication的keyWindow 通过代码加载 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *viewController = [[UIViewController alloc] init]; self.window.rootViewController = viewController; [self.window makeKeyAndVisible]; return YES;&#125; ​ 首先创建串口，获取到一个UIWindow实例来显示界面。（self.window为系统自带） 创建一个控制器，将该控制器设置为根控制器 显示窗口[self.window makeKeyAndVisible] 结束程序]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统搭建基于GitHhub的Hexo博客]]></title>
    <url>%2F2018%2F01%2F23%2FMac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHhub%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 注册GitHub帐号 进入GitHub官网注册帐号 创建一个仓库，名称为 yourname.github.io 其中yourname是你的github名称,按照这个规则创建才有用。如你的github注册名称为jack那你创建的仓库名称为jack.github.io 2. 安装node.js 进入nodejs官网下载一步步安装即可,建议安装通用版。 安装完成后可以在终端测试 Node.js 和npm 是否可以使用了。 查看 Node.js 的版本号在终端里输入如下命令：node -v 如果Node.js 成功安装，可以看到类似如下的信息：v6.5.0。查看npm 的版本号在终端里输入如下命令：npm -v如果npm 成功安装，可以看到类似如下的信息：3.10.3。注意命令中间有空格。 3. 安装hexo 可以查看Hexo中文文档 在终端输入 npm install -g hexo-cli 安装 如果Mac系统在安装过程中报错需要安装命令行工具 在终端中输入命令 xcode-select --install会弹出一个窗口选择安装即可。安装完成后输入命令 gcc-v会看到如下信息 Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.5.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin说明安装完成 安装完命令行工具后再输入 $ npm install -g hexo-cli 来安装Hexo，安装完成后输入 hexo 命令会出现下图 4. 初始化博客 新建一个文件夹如我是在文档下新建了一个名称为blog的文件夹名字可以随便取在终端cd到该文件夹 cd Documents/blog/ 然后运行 hexo init命令行，速度取决于网速，可能需要几分钟完成，成功后会在blog目录下生成相关文件，如图 安装完成后运行 hexo s 现在即可在浏览器本地访问 http://localhost:4000/ 会出现下图证明安装成功 5. 关联GitHub 终端 open Documents/blog/ 打开刚才新建的blog文件夹就是我们把hexo init的那个文件夹。打开文件夹下 _config.yml文件,建议使用Sublime Text打开其他文本编辑器也行，滑到最下面修改成如下样子,将我的名字改成你的名字。 注意：在配置所有的_config.yml文件时（包括theme中的）在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 在blog文件夹目录下执行生成静态页面命令：hexo g 然后执行hexo d执行hexo d部署需要你的github用户名和密码 6. 发布文章 终端cd到blog文件夹下运行 hexo new “firstName”名为firstName.md的文件会建在目录/blog/source/_posts下，firstName是文件名.建议使用Mou编辑器。如下图，新建title：为文章名称，date：创建时间，tags:文章所属标签，categories：文章所属分类，注意刚开始新建的文章打开是没有分类的需要修改新建文章模版，打开目录下scaffolds文件夹下的post.md文件在标签上面添加 categories:后续新建文章就会添加分类栏目。 如下图是这篇文章的属性，分类和标签可修改成任意名称，Hexo会自动根据标签和分类归纳文章。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[惯例]]></title>
    <url>%2F2018%2F01%2F18%2Findex%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
  </entry>
</search>
