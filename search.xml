<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UIScrollView]]></title>
    <url>%2F2018%2F01%2F29%2FUIScrollView%2F</url>
    <content type="text"><![CDATA[简介UIScrollView是UIView的子类，这是一个可以处理滚动操作的UI控件在开发过程中使用很频繁。 属性123456789101112131415@property(nonatomic) CGPoint contentOffset;//内容偏移量，当前显示的内容得顶点相对此控件顶点x,y轴之间的距离，默认为CGPointZero@property(nonatomic) CGSize contentSize;//控件内容大小，不一定在显示区域，如果这个属性不设置，此控件将无法滚动，默认为CGSizeZero;@property(nonatomic) UIEdgeInsets contentInset;//控件四周边距，类似于css中的margin，注意边距不座位其内容的一部分，默认为UIEdgeInsertZero;@property(nonatomic,assign) id&lt;UIScrollViewDelegate&gt; delegate; //控件代理，一般用于事件监听，在iOS中多数控件都是通过代理来进行事件监听的@property(nonatomic) BOOL bounces;//启用弹簧效果，启用弹簧效果后拖动到边缘可以看到内容后面的背景，默认设置为YES@property(nonatomic,getter=isPagingEnabled)BOOL pagingEnabled;//是否分页，如果分页的话每次左右拖动的距离只屏幕宽度的整倍数，默认设置为NO@property(nonatomic,getter=isScrollEnabled)BOOL scrollEnabled;//是否启用滚动，默认也YES@property(nonatomic) BOOL showsHorizontalScrollIndicator;//是否显示横向滚动条，默认为YES@property(nonatomic) BOOL showsVerticalScrollIndicator;//是否显示纵向滚动条，默认为YES@property(nonatomic) CGFloat minimumZoomScale;//最小缩放倍数，默认为1.0@property(nonatomic) CGFloat maximumZoomScale;//最大缩放倍数(注意只有maximumZoomScale大于minimumZoomScale才有可能缩放)默认为1.0@property(nonatomic,readonly,getter= isTracking)BOOL tracking;//状态是否被追踪，手指按下去并且还没有拖动的时候是YES，其他情况均为NO@property(nonatomic,readonly,getter= isDragging)BOOL dragging;//判断状态是否被拖拽@property(nonatomic,readonly,getter=isDecelerating)BOOL decelerating;//判断状态是否减速@property(nonatomic,readonly,getter=isZomming)BOOL zomming;//判断状态是否缩放 方法12- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;//设置滚动位置，第二个参数表示是否启用动画效果- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;//滚动并显示指定区域的内容，第二个参数表示是否启用动画效果 代理方法12345678- (void)scrollViewDidScroll:(UIScrollView *)scrollView;//滚动事件方法，滚动过程中会一直循环执行- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;//开始拖拽事件- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;//拖拽操作完成事件方法- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;//即将停止滚动事件方法（拖拽松开后开始减速时执行）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;//滚动停止事件方法（滚动过程中减速停止后执行）- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view NS_AVAILABLE_IOS(3_2);//开始缩放事件方法- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2);//缩放操作完成事件方法- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;//返回缩放视图，注意只有实现这个代理方法才能进行缩放，此方法返回需要缩放的视图 简单示例 ViewController.h 1234567891011121314//// ViewController.h// UIScrollView-1//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController @property (nonatomic,strong) UIScrollView *scrollview;@property (nonatomic,strong) UIImageView *imageView;@end ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//// ViewController.m// UIScrollView-1//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"//实现UIScrollView代理@interface ViewController ()&lt;UIScrollViewDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //添加scrollview控件 //注意UIScreen代表当前屏幕对象，applicationFrame是当前屏幕内容区域 _scrollview = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].applicationFrame]; _scrollview.contentMode = UIViewContentModeScaleToFill; [self.view addSubview:_scrollview]; //添加图片控件 UIImage *image = [UIImage imageNamed:@"timg"]; _imageView = [[UIImageView alloc]initWithImage:image]; [_scrollview addSubview:_imageView]; //contentSize必须设置，否则无法滚动，当前设置为图片大小 _scrollview.contentSize = _imageView.frame.size; //实现缩放：maxinumZoomScale必须大于minimumZoomScale同时实现viewForZoomingInScrollView方法 _scrollview.minimumZoomScale = 0.6; _scrollview.maximumZoomScale = 3.0; //设置代理为viewController _scrollview.delegate = self; //边距，不属于内容部分，内容坐标（0，0）指的是内容的左上角不包括边界 //_scrollView.contentInset=UIEdgeInsetsMake(10, 20, 10, 20); //显示滚动内容的指定位置 //_scrollView.contentOffset=CGPointMake(10, 0); //隐藏滚动条 _scrollview.showsHorizontalScrollIndicator = NO; _scrollview.showsVerticalScrollIndicator = NO; //禁用弹簧效果 //_scrollView.bounces=NO;&#125;#pragma mark 代理方法- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; return _imageView;&#125;- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewWillBeginDecelerating");&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewDidEndDecelerating");&#125;-(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewWillBeginDragging");&#125;-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@"scrollViewDidEndDragging");&#125;-(void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view&#123; NSLog(@"scrollViewWillBeginZooming");&#125;-(void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale&#123; NSLog(@"scrollViewDidEndZooming");&#125;#pragma mark 当图片小于屏幕宽高时缩放后让图片显示到屏幕中间- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; CGSize originalSize = _scrollview.bounds.size; CGSize contentSize = _scrollview.contentSize; //计算偏移量X轴 CGFloat offSetx = originalSize.width&gt;contentSize.width?(originalSize.width-contentSize.width)/2:0; //计算偏移量Y轴 CGFloat offSetY = originalSize.height&gt;contentSize.height?(originalSize.height-contentSize.height)/2:0; _imageView.center = CGPointMake(contentSize.width/2+offSetx, contentSize.height/2+offSetY);&#125;@end 效果如下图 ​ UIScrollView实战-实现无限循环 说明 如何无限循环一种是无限循环叠加图片，另一种就是如果最后一张图片浏览完立即显示第一张图片。很明显第一种方法是不现实的，使用第二种方式。其实使用第二种方式实现原理比较简单，只要在图片前后各放一张图片即可（此时共有n+2个图片在UIScrollView中）。例如我们有5张图片，只要使用7个UIImageView依次存放：图片5，图片1，图片2，图片3，图片4，图片5，图片1。当从图片1滚动到图片5时由于最后一张是图片1就给用户一种无限循环的感觉，当这张图完全显示后我们迅速将UIScrollView的contentOffset设置到第二个UIImageView，也就是图片1，接着用户可以继续向后滚动。当然向前滚动原理完全一样，当滚动到第一张图片（图片5）就迅速设置UIScrollView的contentOffset显示第6张图（图片5）。 如何优化性能如果图片过多这些图片势必全部加载到内存消耗很大，其实完全没必要创建n+2个UIImageView，其实3个已经足够，只要一直保持显示中间的UIImageView，滚动时动态更改三个UIImageView的图片即可。例如三个UIImageView默认放图片5、图片1、图片2，当前显示中间的UIImageView，也就是图片1,。如果向后滚动那么就会显示图片2，当图片2显示完整后迅速重新设置三个UIImageView的内容为图片1、图片2、图片3，然后通过contentOffset设置显示中间的UIImageView，也就是图片2。继续向后看到图片3，当图片3滚动完成迅速重新设置3个UIImageView的内容为图片2、图片3、图片4，然后设置contentOffset显示中间的UIImageView，也就是图片3。当然，向前滚动原理完全一样，如此就给用户一种循环错觉，而且不占用过多内存。 通过解析plist文件来加载图片数据 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;0.jpg&lt;/key&gt; &lt;string&gt;图0&lt;/string&gt; &lt;key&gt;1.jpg&lt;/key&gt; &lt;string&gt;图1&lt;/string&gt; &lt;key&gt;2.jpg&lt;/key&gt; &lt;string&gt;图2&lt;/string&gt; &lt;key&gt;3.jpg&lt;/key&gt; &lt;string&gt;图3&lt;/string&gt; &lt;key&gt;4.jpg&lt;/key&gt; &lt;string&gt;图4&lt;/string&gt; &lt;key&gt;5.jpg&lt;/key&gt; &lt;string&gt;图5&lt;/string&gt; &lt;key&gt;6.jpg&lt;/key&gt; &lt;string&gt;图6&lt;/string&gt; &lt;key&gt;7.jpg&lt;/key&gt; &lt;string&gt;图7&lt;/string&gt; &lt;key&gt;8.jpg&lt;/key&gt; &lt;string&gt;图8&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//// ViewController.m// 无限滚动图片//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#define SCREEN_WIDTH 320#define SCREEN_HEIGHT 568#define IMAGEVIEW_COUNT 3@interface ViewController ()&lt;UIScrollViewDelegate&gt;&#123; UIScrollView *_scrollView; UIImageView *_leftImageView; UIImageView *_centerImageView; UIImageView *_rightImageView; UIPageControl *_pageControl; UILabel *_label; NSMutableDictionary *_imageData;//图片数据 int _currentImageIndex;//当前图片索引 int _imageCount;//图片总数&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self loadImageData]; //添加滚动控件 [self addScrollView]; //添加图片控件 [self addImageViews]; //添加分页控件 [self addPageControl]; //添加图片信息描述控件 [self addLabel]; //加载默认图片 [self setDefaultImage];&#125;#pragma mark 加载图片数据- (void)loadImageData&#123; NSString *path = [[NSBundle mainBundle]pathForResource:@"imageInfo" ofType:@"plist"]; _imageData = [NSMutableDictionary dictionaryWithContentsOfFile:path]; _imageCount = _imageData.count;&#125;#pragma mark 添加控件- (void)addScrollView&#123; _scrollView = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].bounds]; [self.view addSubview:_scrollView]; //设置代理 _scrollView.delegate = self; //设置contentSize _scrollView.contentSize = CGSizeMake(IMAGEVIEW_COUNT*SCREEN_WIDTH, SCREEN_HEIGHT); //设置当前显示的位置为中间图片 [_scrollView setContentOffset:CGPointMake(SCREEN_WIDTH, 0) animated:NO]; //设置分页 _scrollView.pagingEnabled=YES; //去掉滚动条 _scrollView.showsHorizontalScrollIndicator=NO;&#125;#pragma mark 添加图片三个控件-(void)addImageViews&#123; _leftImageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _leftImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_leftImageView]; _centerImageView=[[UIImageView alloc]initWithFrame:CGRectMake(SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _centerImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_centerImageView]; _rightImageView=[[UIImageView alloc]initWithFrame:CGRectMake(2*SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _rightImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_rightImageView]; &#125;#pragma mark 设置默认显示图片-(void)setDefaultImage&#123; //加载默认图片 _leftImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",_imageCount-1]]; _centerImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",0]]; _rightImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",1]]; _currentImageIndex=0; //设置当前页 _pageControl.currentPage=_currentImageIndex; NSString *imageName=[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]; _label.text=_imageData[imageName];&#125;#pragma mark 添加分页控件-(void)addPageControl&#123; _pageControl=[[UIPageControl alloc]init]; //注意此方法可以根据页数返回UIPageControl合适的大小 CGSize size= [_pageControl sizeForNumberOfPages:_imageCount]; _pageControl.bounds=CGRectMake(0, 0, size.width, size.height); _pageControl.center=CGPointMake(SCREEN_WIDTH/2, SCREEN_HEIGHT-100); //设置颜色 _pageControl.pageIndicatorTintColor=[UIColor colorWithRed:193/255.0 green:219/255.0 blue:249/255.0 alpha:1]; //设置当前页颜色 _pageControl.currentPageIndicatorTintColor=[UIColor colorWithRed:0 green:150/255.0 blue:1 alpha:1]; //设置总页数 _pageControl.numberOfPages=_imageCount; [self.view addSubview:_pageControl];&#125;#pragma mark 添加信息描述控件-(void)addLabel&#123; _label=[[UILabel alloc]initWithFrame:CGRectMake(0, 10, SCREEN_WIDTH,30)]; _label.textAlignment=NSTextAlignmentCenter; _label.textColor=[UIColor colorWithRed:0 green:150/255.0 blue:1 alpha:1]; [self.view addSubview:_label];&#125;#pragma mark 滚动停止事件-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; //重新加载图片 [self reloadImage]; //移动到中间 [_scrollView setContentOffset:CGPointMake(SCREEN_WIDTH, 0) animated:NO]; //设置分页 _pageControl.currentPage=_currentImageIndex; //设置描述 NSString *imageName=[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]; _label.text=_imageData[imageName];&#125;#pragma mark 重新加载图片-(void)reloadImage&#123; int leftImageIndex,rightImageIndex; CGPoint offset=[_scrollView contentOffset]; if (offset.x&gt;SCREEN_WIDTH) &#123; //向右滑动 _currentImageIndex=(_currentImageIndex+1)%_imageCount; &#125;else if(offset.x&lt;SCREEN_WIDTH)&#123; //向左滑动 _currentImageIndex=(_currentImageIndex+_imageCount-1)%_imageCount; &#125; //UIImageView *centerImageView=(UIImageView *)[_scrollView viewWithTag:2]; _centerImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]]; //重新设置左右图片 leftImageIndex=(_currentImageIndex+_imageCount-1)%_imageCount; rightImageIndex=(_currentImageIndex+1)%_imageCount; _leftImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",leftImageIndex]]; _rightImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",rightImageIndex]];&#125;@end ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UIView解析]]></title>
    <url>%2F2018%2F01%2F27%2FUIView%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UIView是管理屏幕上矩形区域内容的对象，iOS中几乎所有UI控件都是UIView的子类。 三个结构体CGPoint、CGSize、CGRect 1.CGPoint 12345struct CGPoint&#123; CGFloat x; //控件x轴位置 CGFLoat y; //控件Y轴位置&#125; CGSize 12345struct CGSize&#123; CGFloat width; //控件宽度 CGFloat height; //控件高度&#125; CGRect 12345struct CGRect&#123; CGPoint origin; //偏移量是相对父视图的 CGSize size;&#125; 视图的基本属性​ frame和center都是相对父视图来说的，bounds是相对自身来说的 frame是相对于父视图左上角原点(0,0)的位置，改变视图的frame会改变center中心点 center是CGPoint值的就是整个视图的中心点，改变视图的center也会改变frame bounds 是CGRect 是告诉子视图本视图的原点位置(通俗的说就是，子视图的frame的origin与父视图的bounds的origin的差，就是子视图相对于父视图左上角的位置，如果结果为负，则子视图在父视图外) 通过addSubview方法添加的子视图，越后添加，越显示到上层。 移除父视图也会把它里面的子视图移除 基本界面元素 1.UIView 1UIView *myView = [[UIView alloc]initWithFrame:CGrectMake(10,10,50,50)];//创建了一个x轴10，y轴10，宽度为50，高度为50的UIView. 2.UIWindow UIWindow继承自UIView，在系统的初始化过程中创建(application didFinishLauchingWithOptions里面) 123self.window = [[[UIWindos alloc]initWithFrame:[UIScreen mainScreen]bounds]autorelease];self.window.backgroundColor = [UIColor grayColor]; //给window设置一个背景色 [self.window makeKeyAndVisible]; //让window显示出来 UIScreen代表了屏幕 12CGRect screenBounds = [ [UIScreen mainScreen]bounds]; //返回的是带有状态栏的Rect CGRect viewBounds = [ [UIScreen mainScreen]applicationFrame]; //不包含状态栏的Rect ​ UIView的方法 一个 UIView 里面可以包含许多的 Subview（其他的 UIView），而这些 Subview 彼此之间是有所谓的阶层关系，这有点类似绘图软体中图层的概念，下面程式码示演示了几个在管理图层（Subview）上常用的方法，其程式码如下。 1.首先是大家最常使用的新增和移除Subview。 ​123[Subview removeFromSuperview]; //将Subview从当前的UIView中移除 [UIView addSubview:Subview]; //UIView增加一个Subview​ 2.在UIView中将Subview往前或是往后移动一个图层，往前移动会覆盖住较后层的 Subview，而往后移动则会被较上层的Subview所覆盖。 123[UIView bringSubviewToFront:Subview]; //将Subview往前移动一个图层（与它的前一个图层对调位置）//将Subview往前移动一个图层（与它的前一个图层对调位置）[UIView sendSubviewToBack:Subview]; //将Subview往后移动一个图层（与它的后一个图层对调位置) 3.在UIView中使用索引Index交换两的Subview彼此的图层层级。 1[UIView exchangeSubviewAtIndex:indexA withSubviewAtIndex:indexB]; //交换两个图层 4.使用Subview的变数名称取得它在UIView中的索引值（Index ） 1NSInteger index = [[UIView subviews] indexOfObject:Subview名称]; //取得Index 5.替Subview加上NSInteger 的註记(Tag)好让之后它们分辨彼此。 12[Subview setTag:NSInteger]; //加上标记 [UIView viewWithTag:NSInteger]; //通过标记得到view 返回值为UIView 6.最后是取得UIView中所有的Subview，呼叫此方法会传回一个 NSArray，并以由后往前的顺序列出这些 Subview，下图中是列出范例图片里Root中所有的Subview。 1[UIView subviews] ; //取的UIView下的所有Subview UIView常用属性和方法 属性 12345678910@property(nonatomic) CGRect frame;//控件的位置和大小，所有的控件必须指定这个属性，否则即使有控件也无法显示@property(nonatomic) CGRect bounds;//当前控件位置和大小，但是和frame不同的是它的位置是确定的(0,0)@property(nonatomic) CGPoint center;//控件的中心位置，一般用户进行控件定位@property(nonatomic) CGAffineTransform transform;//控件矩阵变化，包括平移、缩放、旋转，默认为CGAffineTransformIdentity@property(nonatomic) UIViewAutoresizing autoresizingMask;//控件旋转时大小自动伸缩，默认为UIViewAutoresizingNone@property(nonatomic,readonly) UIView *superview;//当前控件的父控件@property(nonatomic,readonly,copy) NSArray *subviews;//当前控件的子控件返回一个数组@property(nonatomic,getter=isHidden) BOOL hidden;//是否隐藏，默认为不隐藏。@property(nonatomic) UIViewContentMode contentMode; //控件的显示模式。如ImageView的居中模式等@property(nonatomic) NSInteger tag;//控件的标签属性 方法 1234567- (void)addSubview:(UIView *) view;//添加子控件- (void)removeFromSuperView;//从父控件中移除当前控件- (void)insertSubview:(UIView *)view atIndex:(NSInteger) index; //在指定位置插入子控件- (void)beginAnimations:*(NSString *)animationID context:(void *)context;//开始一段动画+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0);//以block的形式执行一段动画，注意这个方法有几种相关的方法- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2); //添加手势操作- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2); //移除手势操作 上面所有位置的属性都是相对于父控件而言（不是相对主屏幕而言） ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS程序启动过程]]></title>
    <url>%2F2018%2F01%2F26%2FiOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[点击程序图标打开程序 执行main函数 执行UIApplicationMain函数 通过UIApplicationMain方法的反射创建UIApplication对象设置代理，开启消息循环 开启监听程序事件 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//程序加载完毕后调用该方法&#125;- (void)applicationWillResignActive:(UIApplication *)application &#123;//程序失去焦点调用该方法&#125;- (void)applicationDidEnterBackground:(UIApplication *)application &#123;//程序进入后台调用该方法&#125;- (void)applicationWillEnterForeground:(UIApplication *)application &#123;//程序从后台将要进入前台调用该方法&#125;- (void)applicationDidBecomeActive:(UIApplication *)application &#123;//内存经过，程序将要停止调用该方法&#125;- (void)applicationWillTerminate:(UIApplication *)application &#123;//程序将要退出调用该方法&#125; 加载info.plist程序配置文件，主要是看我们用的是Storyboard方式加载还是代码的方式加载。 通过storyboard方式加载 在程序启动完成的时候系统自动创建一个UIWindow的实例来显示界面 1@property (strong, nonatomic) UIWindow *window; 设置窗口的根控制器 根据storyboard的设置，创建一个控制器。 并且设置这个控制器为之前创建的UIWindow的根控制器 显示窗口。（makeKeyAndVisible） 设置self.window可见并且设置UIApplication的keyWindow 通过代码加载 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *viewController = [[UIViewController alloc] init]; self.window.rootViewController = viewController; [self.window makeKeyAndVisible]; return YES;&#125; ​ 首先创建串口，获取到一个UIWindow实例来显示界面。（self.window为系统自带） 创建一个控制器，将该控制器设置为根控制器 显示窗口[self.window makeKeyAndVisible] 结束程序]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统搭建基于GitHhub的Hexo博客]]></title>
    <url>%2F2018%2F01%2F23%2FMac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHhub%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 注册GitHub帐号 进入GitHub官网注册帐号 创建一个仓库，名称为 yourname.github.io 其中yourname是你的github名称,按照这个规则创建才有用。如你的github注册名称为jack那你创建的仓库名称为jack.github.io 2. 安装node.js 进入nodejs官网下载一步步安装即可,建议安装通用版。 安装完成后可以在终端测试 Node.js 和npm 是否可以使用了。 查看 Node.js 的版本号在终端里输入如下命令：node -v 如果Node.js 成功安装，可以看到类似如下的信息：v6.5.0。查看npm 的版本号在终端里输入如下命令：npm -v如果npm 成功安装，可以看到类似如下的信息：3.10.3。注意命令中间有空格。 3. 安装hexo 可以查看Hexo中文文档 在终端输入 npm install -g hexo-cli 安装 如果Mac系统在安装过程中报错需要安装命令行工具 在终端中输入命令 xcode-select --install会弹出一个窗口选择安装即可。安装完成后输入命令 gcc-v会看到如下信息 Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.5.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin说明安装完成 安装完命令行工具后再输入 $ npm install -g hexo-cli 来安装Hexo，安装完成后输入 hexo 命令会出现下图 4. 初始化博客 新建一个文件夹如我是在文档下新建了一个名称为blog的文件夹名字可以随便取在终端cd到该文件夹 cd Documents/blog/ 然后运行 hexo init命令行，速度取决于网速，可能需要几分钟完成，成功后会在blog目录下生成相关文件，如图 安装完成后运行 hexo s 现在即可在浏览器本地访问 http://localhost:4000/ 会出现下图证明安装成功 5. 关联GitHub 终端 open Documents/blog/ 打开刚才新建的blog文件夹就是我们把hexo init的那个文件夹。打开文件夹下 _config.yml文件,建议使用Sublime Text打开其他文本编辑器也行，滑到最下面修改成如下样子,将我的名字改成你的名字。 注意：在配置所有的_config.yml文件时（包括theme中的）在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 在blog文件夹目录下执行生成静态页面命令：hexo g 然后执行hexo d执行hexo d部署需要你的github用户名和密码 6. 发布文章 终端cd到blog文件夹下运行 hexo new “firstName”名为firstName.md的文件会建在目录/blog/source/_posts下，firstName是文件名.建议使用Mou编辑器。如下图，新建title：为文章名称，date：创建时间，tags:文章所属标签，categories：文章所属分类，注意刚开始新建的文章打开是没有分类的需要修改新建文章模版，打开目录下scaffolds文件夹下的post.md文件在标签上面添加 categories:后续新建文章就会添加分类栏目。 如下图是这篇文章的属性，分类和标签可修改成任意名称，Hexo会自动根据标签和分类归纳文章。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[惯例]]></title>
    <url>%2F2018%2F01%2F18%2Findex%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
  </entry>
</search>
