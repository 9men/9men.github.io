<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UIView解析]]></title>
    <url>%2F2018%2F01%2F27%2FUIView%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UIView是管理屏幕上矩形区域内容的对象，iOS中几乎所有UI控件都是UIView的子类。 三个结构体CGPoint、CGSize、CGRect 1.CGPoint 12345struct CGPoint&#123; CGFloat x; //控件x轴位置 CGFLoat y; //控件Y轴位置&#125; CGSize 12345struct CGSize&#123; CGFloat width; //控件宽度 CGFloat height; //控件高度&#125; CGRect 12345struct CGRect&#123; CGPoint origin; //偏移量是相对父视图的 CGSize size;&#125; 视图的基本属性​ frame和center都是相对父视图来说的，bounds是相对自身来说的 frame是相对于父视图左上角原点(0,0)的位置，改变视图的frame会改变center中心点 center是CGPoint值的就是整个视图的中心点，改变视图的center也会改变frame bounds 是CGRect 是告诉子视图本视图的原点位置(通俗的说就是，子视图的frame的origin与父视图的bounds的origin的差，就是子视图相对于父视图左上角的位置，如果结果为负，则子视图在父视图外) 通过addSubview方法添加的子视图，越后添加，越显示到上层。 移除父视图也会把它里面的子视图移除 基本界面元素 1.UIView 1UIView *myView = [[UIView alloc]initWithFrame:CGrectMake(10,10,50,50)];//创建了一个x轴10，y轴10，宽度为50，高度为50的UIView. 2.UIWindow UIWindow继承自UIView，在系统的初始化过程中创建(application didFinishLauchingWithOptions里面) 123self.window = [[[UIWindos alloc]initWithFrame:[UIScreen mainScreen]bounds]autorelease];self.window.backgroundColor = [UIColor grayColor]; //给window设置一个背景色 [self.window makeKeyAndVisible]; //让window显示出来 UIScreen代表了屏幕 12CGRect screenBounds = [ [UIScreen mainScreen]bounds]; //返回的是带有状态栏的Rect CGRect viewBounds = [ [UIScreen mainScreen]applicationFrame]; //不包含状态栏的Rect ​ UIView的方法 一个 UIView 里面可以包含许多的 Subview（其他的 UIView），而这些 Subview 彼此之间是有所谓的阶层关系，这有点类似绘图软体中图层的概念，下面程式码示演示了几个在管理图层（Subview）上常用的方法，其程式码如下。 1.首先是大家最常使用的新增和移除Subview。 ​123[Subview removeFromSuperview]; //将Subview从当前的UIView中移除 [UIView addSubview:Subview]; //替UIView增加一个Subview​ 2.在UIView中将Subview往前或是往后移动一个图层，往前移动会覆盖住较后层的 Subview，而往后移动则会被较上层的Subview所覆盖。 123[UIView bringSubviewToFront:Subview]; //将Subview往前移动一个图层（与它的前一个图层对调位置）//将Subview往前移动一个图层（与它的前一个图层对调位置）[UIView sendSubviewToBack:Subview]; //将Subview往后移动一个图层（与它的后一个图层对调位置) 3.在UIView中使用索引Index交换两的Subview彼此的图层层级。 1[UIView exchangeSubviewAtIndex:indexA withSubviewAtIndex:indexB]; //交换两个图层 4.使用Subview的变数名称取得它在UIView中的索引值（Index ） 1NSInteger index = [[UIView subviews] indexOfObject:Subview名称]; //取得Index 5.替Subview加上NSInteger 的註记(Tag)好让之后它们分辨彼此。 12[Subview setTag:NSInteger]; //加上标记 [UIView viewWithTag:NSInteger]; //通过标记得到view 返回值为UIView 6.最后是取得UIView中所有的Subview，呼叫此方法会传回一个 NSArray，并以由后往前的顺序列出这些 Subview，下图中是列出范例图片里Root中所有的Subview。 1[UIView subviews] ; //取的UIView下的所有Subview]]></content>
      <categories>
        <category>ios开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS程序启动过程]]></title>
    <url>%2F2018%2F01%2F26%2FiOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[点击程序图标打开程序 执行main函数 执行UIApplicationMain函数 通过UIApplicationMain方法的反射创建UIApplication对象设置代理，开启消息循环 开启监听程序事件 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//程序加载完毕后调用该方法&#125;- (void)applicationWillResignActive:(UIApplication *)application &#123;//程序失去焦点调用该方法&#125;- (void)applicationDidEnterBackground:(UIApplication *)application &#123;//程序进入后台调用该方法&#125;- (void)applicationWillEnterForeground:(UIApplication *)application &#123;//程序从后台将要进入前台调用该方法&#125;- (void)applicationDidBecomeActive:(UIApplication *)application &#123;//内存经过，程序将要停止调用该方法&#125;- (void)applicationWillTerminate:(UIApplication *)application &#123;//程序将要退出调用该方法&#125; 加载info.plist程序配置文件，主要是看我们用的是Storyboard方式加载还是代码的方式加载。 通过storyboard方式加载 在程序启动完成的时候系统自动创建一个UIWindow的实例来显示界面 1@property (strong, nonatomic) UIWindow *window; 设置窗口的根控制器 根据storyboard的设置，创建一个控制器。 并且设置这个控制器为之前创建的UIWindow的根控制器 显示窗口。（makeKeyAndVisible） 设置self.window可见并且设置UIApplication的keyWindow 通过代码加载 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *viewController = [[UIViewController alloc] init]; self.window.rootViewController = viewController; [self.window makeKeyAndVisible]; return YES;&#125; ​ 首先创建串口，获取到一个UIWindow实例来显示界面。（self.window为系统自带） 创建一个控制器，将该控制器设置为根控制器 显示窗口[self.window makeKeyAndVisible] 结束程序]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统搭建基于GitHhub的Hexo博客]]></title>
    <url>%2F2018%2F01%2F23%2FMac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHhub%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 注册GitHub帐号 进入GitHub官网注册帐号 创建一个仓库，名称为 yourname.github.io 其中yourname是你的github名称,按照这个规则创建才有用。如你的github注册名称为jack那你创建的仓库名称为jack.github.io 2. 安装node.js 进入nodejs官网下载一步步安装即可,建议安装通用版。 安装完成后可以在终端测试 Node.js 和npm 是否可以使用了。 查看 Node.js 的版本号在终端里输入如下命令：node -v 如果Node.js 成功安装，可以看到类似如下的信息：v6.5.0。查看npm 的版本号在终端里输入如下命令：npm -v如果npm 成功安装，可以看到类似如下的信息：3.10.3。注意命令中间有空格。 3. 安装hexo 可以查看Hexo中文文档 在终端输入 npm install -g hexo-cli 安装 如果Mac系统在安装过程中报错需要安装命令行工具 在终端中输入命令 xcode-select --install会弹出一个窗口选择安装即可。安装完成后输入命令 gcc-v会看到如下信息 Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.5.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin说明安装完成 安装完命令行工具后再输入 $ npm install -g hexo-cli 来安装Hexo，安装完成后输入 hexo 命令会出现下图 4. 初始化博客 新建一个文件夹如我是在文档下新建了一个名称为blog的文件夹名字可以随便取在终端cd到该文件夹 cd Documents/blog/ 然后运行 hexo init命令行，速度取决于网速，可能需要几分钟完成，成功后会在blog目录下生成相关文件，如图 安装完成后运行 hexo s 现在即可在浏览器本地访问 http://localhost:4000/ 会出现下图证明安装成功 5. 关联GitHub 终端 open Documents/blog/ 打开刚才新建的blog文件夹就是我们把hexo init的那个文件夹。打开文件夹下 _config.yml文件,建议使用Sublime Text打开其他文本编辑器也行，滑到最下面修改成如下样子,将我的名字改成你的名字。 注意：在配置所有的_config.yml文件时（包括theme中的）在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 在blog文件夹目录下执行生成静态页面命令：hexo g 然后执行hexo d执行hexo d部署需要你的github用户名和密码 6. 发布文章 终端cd到blog文件夹下运行 hexo new “firstName”名为firstName.md的文件会建在目录/blog/source/_posts下，firstName是文件名.建议使用Mou编辑器。如下图，新建title：为文章名称，date：创建时间，tags:文章所属标签，categories：文章所属分类，注意刚开始新建的文章打开是没有分类的需要修改新建文章模版，打开目录下scaffolds文件夹下的post.md文件在标签上面添加 categories:后续新建文章就会添加分类栏目。 如下图是这篇文章的属性，分类和标签可修改成任意名称，Hexo会自动根据标签和分类归纳文章。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[惯例]]></title>
    <url>%2F2018%2F01%2F18%2Findex%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
  </entry>
</search>
