<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Runtime]]></title>
    <url>%2F2018%2F06%2F20%2FRuntime%2F</url>
    <content type="text"><![CDATA[Runtime简介 Runtime简称运行时，OC就是运行时机制的语言，也就是在运行时候会有一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用那个函数 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用那个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 Runtime作用 发送消息 方法调用的本质，就是让对象发送消息 objc_msgSend只有对象才能发送，因此以objc开头 使用消息机制前提，必须导入#import 消息机制简单使用 12345678910111213141516//创建person对象Person *p = [[Person alloc]init];//调用对象方法[p eat];//本质：让对象发送消息objc_msgSend(p,@selector(eat));//调用类方法的方式：两种//第一种通过类名调用[Person eat];//第二种通过类对象调用[[Person class]eat];//用类名调用类方法，底层会自动把类名转换成类对象调用objc_msgSend([Person class],@selector(eat)); 消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现 交换方法 开发使用场景：系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一：继承系统的类，重写方法 方式二：使用Runtime交换方法 123456789101112131415161718192021222324252627282930313233343536@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"]; &#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName); &#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"加载空的图片"); &#125; return image;&#125;@end 动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "Person.h"#import &lt;objc/message.h&gt;@implementation Person//默认方法都有两个隐式参数 void eat(id self,SEL sel)&#123; NSLog(@"%@ %@",self,NSStringFromSelector(sel));&#125;/*当一个对象调用未实现的方法，会调用这个方法处理，并且会把对应的方法列表传过来，刚好可以判断，未实现的方法是不是我们想要动态添加的方法。*/+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel== @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; return [super resolveInstanceMethod:sel];&#125;@end #import "ViewController.h"#import "Person.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc]init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)]; &#125;@end 给分类添加属性 给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类内存空间。 1234567891011121314151617181920212223242526272829@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"小码哥"; NSLog(@"%@",objc.name); &#125;@end// 定义关联的keystatic const char *key = "name";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性 解决：提供一个分类，专门根据字典生成对应的属性字符串 123456789101112131415161718192021222324252627282930313233343536373839404142@implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM); &#125;@end 字典转模型的方式一：KVC 1234567891011@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status; &#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致就会出现找不到key的错误。 解决：重写对象的setValue:forUndefinedKey把系统方法覆盖，就能继续使用KVC字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; &#125; 字典转模型的方式二：Runtime 利用运行时，遍历模型中的所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@"statuses"]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@"user"]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@"%@ %@",_statuses,[_statuses[0] user]); &#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end - -]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop]]></title>
    <url>%2F2018%2F05%2F10%2FRunLoop%2F</url>
    <content type="text"><![CDATA[RunLoop基本概念 字面意思运行循环，作用保持程序的持续运行，处理app中的各种事件（比如触摸事件、定时器事件［NSTimer］、selector事件），节省CPU资源，提高程序性能，有事情就做事情，没事就休息 说明 如果没有RunLoop那么程序一启动就会退出，什么吗事情都做不了，有了RunLoop相当于在内部有一个死循环，能够保证程序的持续运行 main韩式中的RunLoop(在UIApplication函数内部就启动了一个RunLoop该函数返回一个int类型的值，这个默认启动的RunLoop是跟主线程相关联的) RunLoop对象 在iOS开发中有两套api来访问RunLoop分别是NSRunLoop和CFRunLoopRef NSRunLoop和CFRunLoopRef都代表着RunLoop对象，它们是等价的，可以互相转换 NSRunLoop是基于CFRunLoopRef的一层OC包装。 RunLoop与线程 一个RunLoop对应着一条唯一的线程，如果要让子线程不死，必须给这条线程创建一个RunLoop 主线程的RunLoop会自动创建好，子线程的RunLoop需要手动创建 RunLoop在第一次获取的时候创建，在结束线程时销毁 获得RunLoop对象 12345678910111213//获得当前RunLoop对象//NSRunLoopNSRunLoop *runloop1 = [NSRunLoop currentRunLoop];CFRunLoopRef runloop2 = CGFRunLoopGetCurrent();//拿到当前应用程序的主RunLoop(主线程线程对应的RunLoop)NSRunLoop *runloopmain1 = [NSRunLoop mainRunLoop];CFRunLoopRef runloopmain2 = CFRunLoopGetMain();/*注意：开一个子线程创建runloop不实通过alloc init方法创建，而是直接调用currentRunLoop方法来创建，它本身是一个懒加载创建。在子线程中，如果不主动获取RunLoop的话，那么子线程内部是不会创建RunLoop的。RunLoop对象是利用字典来进行存储，而且key是对应的线程Value为该线程队员的RunLoop。*/ RunLoop运行原理图 五个相关的类 1234567/*CFRunloopRefCFRunloopModeRef(Runloop运行模式)CFRunloopSourceRef(Runloop要处理的事件源)CFRunloopTimeRef(Timer事件)CFRunloopObserverRef(Runloop的监听者)*/ RunLoop和相关类之间的关系图 RunLoop要想跑起来，它的内部必须要有一个mode，这个mode里面必须有source、observer、timer至少要有其中的一个 CFRunloopModeRef 12345678910111213/*CFRunLoopModeRef代表着RunLoop的运行模式一个RunLoop中可以有多个mode，一个mode里面可以有多个source、observer、timer等等每次runloop启动的时候，只能制定一个mode，这个mode被称为该RunLoop的当前mode如果需要切换mode，只能先退出当前RunLoop，再重新制定一个mode进入这样做主要是为了分割不同组的定时器等，让她们相互之间不受影响系统默认注册了5个mode1.kCFRunLoopDefaultMode:App的默认Mode，通常主线程是在这个Mode下运行2.UITrackingRunLoopMode:界面追踪Mode，用于ScrollView追踪触摸华东，保证节目滑动时不受其他mode影响3.UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode，启动完成后就不再使用。4.GSREventReceiveRunLoopMode:接受系统事件的内部mode，通常使用不到5.KCFRunLoopCommonModes:这是一个占位用的mode，不是一种真正的mode*/ CFRunloopTimerRef NSTimer相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 说明： （1）runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就都不关心，一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。 （2）它是基于时间的触发器，说直白点那就是时间到了我就触发一个事件，触发一个操作。基本上说的就是NSTimer （3）相关代码*/- (void)timer2&#123; //NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES]; //更改模式 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&#125;- (void)timer1&#123; // [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES]; NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES]; //定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作 // [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; //定时器添加到NSDefaultRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作 // [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; //占位模式：common modes标记 //被标记为common modes的模式 kCFRunLoopDefaultMode UITrackingRunLoopMode [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; // NSLog(@"%@",[NSRunLoop currentRunLoop]);&#125;- (void)run&#123; NSLog(@"---run---%@",[NSRunLoop currentRunLoop].currentMode);&#125;- (IBAction)btnClick &#123; NSLog(@"---btnClick---");&#125; GCD中的定时器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//0.创建一个队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.创建一个GCD的定时器 /* 第一个参数：说明这是一个定时器 第四个参数：GCD的回调任务添加到那个队列中执行，如果是主队列则在主线程执行 */ dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); //2.设置定时器的开始时间，间隔时间以及精准度 //设置开始时间，三秒钟之后调用 dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,3.0 *NSEC_PER_SEC); //设置定时器工作的间隔时间 uint64_t intevel = 1.0 * NSEC_PER_SEC; /* 第一个参数：要给哪个定时器设置 第二个参数：定时器的开始时间DISPATCH_TIME_NOW表示从当前开始 第三个参数：定时器调用方法的间隔时间 第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0 该参数的意义：可以适当的提高程序的性能 注意点：GCD定时器中的时间以纳秒为单位（面试） */ dispatch_source_set_timer(timer, start, intevel, 0 * NSEC_PER_SEC); //3.设置定时器开启后回调的方法 /* 第一个参数：要给哪个定时器设置 第二个参数：回调block */ dispatch_source_set_event_handler(timer, ^&#123; NSLog(@"------%@",[NSThread currentThread]); &#125;); //4.执行定时器 dispatch_resume(timer); //注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用 self.timer = timer;GCD定时器补充/* DISPATCH_SOURCE_TYPE_TIMER 定时响应（定时器事件） DISPATCH_SOURCE_TYPE_SIGNAL 接收到UNIX信号时响应 DISPATCH_SOURCE_TYPE_READ IO操作，如对文件的操作、socket操作的读响应 DISPATCH_SOURCE_TYPE_WRITE IO操作，如对文件的操作、socket操作的写响应 DISPATCH_SOURCE_TYPE_VNODE 文件状态监听，文件被删除、移动、重命名 DISPATCH_SOURCE_TYPE_PROC 进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号 下面两个都属于Mach相关事件响应 DISPATCH_SOURCE_TYPE_MACH_SEND DISPATCH_SOURCE_TYPE_MACH_RECV 下面两个都属于自定义的事件，并且也是有自己来触发 DISPATCH_SOURCE_TYPE_DATA_ADD DISPATCH_SOURCE_TYPE_DATA_OR */ CFRunloopSourceRef 123456789101112131415/* 1.是事件源也就是输入源，有两种分类模式； 一种是按照苹果官方文档进行划分的 另一种是基于函数的调用栈来进行划分的（source0和source1）。 2.具体的分类情况 （1）以前的分法 Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources （2）现在的分法 Source0：非基于Port的 Source1：基于Port的 3.可以通过打断点的方式查看一个方法的函数调用栈*/ CFRunLoopObserverRef CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 如何监听 12345678910//创建一个runloop监听者 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; NSLog(@"监听runloop状态改变---%zd",activity); &#125;); //为runloop添加一个监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); CFRelease(observer); 监听的状态 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Runloop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理NSTimer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Sources kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出runloop kCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变&#125;; RunLoop运行逻辑 RunLoop的事件队列 每次运行runloop，你线程的runloop会自动处理之前未处理的消息，并通知相关的观察者。具体顺序如下 通知观察者runloop已经启动 通知观察者任何几件要开始的定时器 通知观察者任何即将启动的非基于端口的源 启动任何准好的非基于端口的源 如果基于端口的源准备好并处于等待状态，立即启动，并进入步骤9 通知观察者进入休眠 将线程置于休眠到任何下一个事件发生 某一事件到达基于端口的源 定时器启动 runloop设置的时间已经超时 runloop被显示唤醒 通知观察者线程被唤醒 处理未处理的时间 如果用户定义的定时器启动，处理定时器事件并重启run loop。进入步骤2 如果输入源启动，传递相应消息 如果run loop被显示唤醒而且时间还没超时，重启run loop。进入步骤2 通知观察者run loop结束。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多线程]]></title>
    <url>%2F2018%2F05%2F09%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基本概念 进程 进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用并且受保护的内存内。 线程 一个进程想要执行任务，必须至少要有一个线程，也可以有多条线程，线程是进程的基本执行单位。 线程的串行 一个进程中有多条线程，这些线程是一个个顺序执行这些任务。 线程的并行 一个进程中有多条线程，这些线程是同时执行这些任务。其实在同一时间内，CPU只能处理一条线程，只有一条线程执行，并发同时执行是CPU在多条线程之间快速切换，只是CPU调度速度足够快，造成了同时并发执行的假象。 多线程优缺点 优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU，内存利用率） 缺点 开启线程需要占用一定的内存空间（如果开启大量的线程，会占用大量的内存空间，降低程序的性能） 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 多线程在iOS开发中的应用 主线程 一个iOS程序运行后，会默认开启1条线程，称为主线程或UI线程 作用是刷新UI，处理UI事件 使用注意 不要将耗时的操作放到主线程中去处理，会卡住线程 和UI相关的刷新操作必须放到主线程中进行处理 iOS中多线程的实现方案 pthread 一套通用的多线程API，适用于Unix\Linux\Windows等系统，跨平台\可移植，使用难度较大，使用频率较低，线程生命周期由程序员进行管理 12345678910说明：pthread的基本使用（需要包含头文件） //使用pthread创建线程对象 pthread_t thread; NSString *name = @"abcd"; //使用pthread创建线程 //第一个参数：线程对象地址 //第二个参数：线程属性 //第三个参数：指向函数的指针 //第四个参数：传递给该函数的参数 pthread_create(&amp;thread, NULL, run, (__bridge void *)(name)); NSThread 使用面向对象，简单易用，，可直接操作线程对象，使用OC对象，使用频率偶尔使用，线程生命周期由程序员进行管理 基本使用 123456789101112131415161718192021222324//第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置 //创建线程 /* 第一个参数：目标对象 第二个参数：选择器，线程启动要调用哪个方法 第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil） */ NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@"abcd"]; //启动线程 [thread start];//第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置 /* 第一个参数：线程启动调用的方法 第二个参数：目标对象 第三个参数：传递给调用方法的参数 */ [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@"我是分离出来的子线程"];//第三种创建线程的方式：后台线程//特点：自动启动县城，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@"我是后台线程"]; 设置线程的属性 12345//设置线程的属性//设置线程的名称thread.name = @"线程A";//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5thread.threadPriority = 1.0; 线程的状态 123456//线程的各种状态：新建-就绪－运行－阻塞－死亡//常用控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntiDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意线程死了就不能复生 线程安全 - 多个线程访问同一块资源会发生数据安全问题，解决方法为加互斥锁，@synchronized(self){}，线程同步 线程间通信 1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@"图片地址"]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; GCD 替代NSThread等多线程技术，充分利用设备的多核（自动）使用语言C语言，使用频率经常使用，线程生命周期为自动管理 两个核心概念队列和任务，同步函数和异步函数 123456789/*01 异步函数+并发队列：开启多条线程，并发执行任务02 异步函数+串行队列：开启一条线程，串行执行任务03 同步函数+并发队列：不开线程，串行执行任务04 同步函数+串行队列：不开线程，串行执行任务05 异步函数+主队列：不开线程，在主线程中串行执行任务06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）07 注意同步函数和异步函数在执行顺序上面的差异*/ GCD线程间通信 123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@"下载操作所在的线程--%@",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@"刷新UI---%@",[NSThread currentThread]); &#125;); &#125;); GCD常见函数 123456789101112131415161718192021222324252627282930313233343536//栅栏函数（控制任务的执行顺序）dispatch_barrier_async(queue, ^&#123; NSLog(@"--dispatch_barrier_async-"); &#125;);//延迟执行（延迟·控制在哪个线程执行）dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"---%@",[NSThread currentThread]); &#125;);// 一次性代码（注意不能放到懒加载）-(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@"-----"); &#125;); &#125;//快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;);//队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); //进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用 NSOperation 基于GCD（底层是GCD）比GCD多了一些更简单实用的功能，使用更加面向对象，使用语言为OC语言，使用频率经常使用，线程生命周期为自动管理 两个核心概念队列和操作 NSOperation本身是抽象类，只能使用它的子类，三个子类分别是：NSBlockOperation、NSINvocationOperation以及自定义继承自NSOperation的类，NSOperation和NSOperationQueue结合实现多线程并发 1234567891011121314151617181920212223242526272829303132333435363738//NSInvocationOperation//封装操作/*第一个参数：目标对象第二个参数：该操作要调用的方法，最大接受一个参数第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil*/NSInvocationOperation ＊operation ＝ [NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];//启动操作[operation start];//--------------------------------------------------------------------------//NSBlockOperation//封装操作 NSBlockOperation提供了一个类方法，在该类方法中封装操作NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; //在主线程中执行 NSLog(@"--download1--",[NSThread currentThread]);&#125;];//追加操作，追加的操作在子线程中执行[operaction addExecutionBlock:^&#123; NSLog(@"--download2--",[NSThread currentThread]);&#125;];[operaction addExecutionBlock:^&#123; NSLog(@"--download3--",[NSThread currentThread]);&#125;];//启动执行操作[operation start];//--------------------------------------------------------------------------//自定义NSOperation//继承NSOperation，通过充血内部的main方法实现封装操作- (void)main&#123; NSLog(@"--main--%@",[NSThread currentThread]);&#125;[op start]; NSOperationQueue基本使用 NSOperationQueue中的两种队列 主队列 通过mainQueue获得，凡是放到主队列中的任务都在主线程执行 非主队列 直接alloc init出来的队列。非主队列同时具备了并发和串行的功能，通过设置最大并发数属性来控制任务是并发执行还是串行执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//自定义NSOperation- (void)customOperation&#123; //创建队列 NSOperationQueue ＊queue = [NSOperationQueue alloc]init]; MyOperation *op1 = [MyOperation alloc]init]; MyOperation *op2 = [MyOperation alloc]init]; [queue addOperation:op1]; [queue addOperation:op2];&#125;//NSBlockOperation- (void)block&#123; //创建队列 NSOperationQueue ＊queue = [NSOperationQueue alloc]init]; NSBlockOperation *op1 = [NSBlockOperation blockOperationWIthBlock:^&#123; NSLog(@"1-------%@",[NSThread currentThread]); &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWIthBlock:^&#123; NSLog(@"2-------%@",[NSThread currentThread]); &#125;]; [op2 addExecutionBlock:^&#123; NSLog(@"3-------%@",[NSThread currentThread]); &#125;]; [op2 addExecutionBlock:^&#123; NSLog(@"4-------%@",[NSThread currentThread]); &#125;]; [queue addOperation:op1]; [queue addOperation:op2]; //简便方法 [queue addOperationWithBlock:^&#123; NSLog(@"5------%@",[NSThread currentThread]); &#125;];&#125;//NSInvocationOperation- (void)invocation&#123; /* GCD中的队列： 串行队列：自己创建的，主队列 并发队列：自己创建的，全局并发队列 NSOperationQueue 主队列：[NSOperationQueue mainqueue];凡事放在主队列中的操作都在主线程中执行 非主队列：[[NSOperationQueue alloc]init]，并发和串行，默认是并发执行的 */ //1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.封装操作 NSInvocationOperation *op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(download1) object:nil]; NSInvocationOperation *op2 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(download2) object:nil]; NSInvocationOperation *op3 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(download3) object:nil]; //3.把封装好的操作添加到队列中 [queue addOperation:op1];//[op1 start] [queue addOperation:op2]; [queue addOperation:op3];&#125; NSOperation其它用法 设置最大并发数（控制任务并发和串行） 123456789//创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.设置最大并发数 //注意点：该属性需要在任务添加到队列中之前进行设置 //该属性控制队列是串行执行还是并发执行 //如果最大并发数等于1，那么该队列是串行的，如果大于1那么是并行的 //系统的最大并发数有个默认的值，为-1，如果该属性设置为0，那么不会执行任何任务 queue.maxConcurrentOperationCount = 2; 暂停和恢复以及取消 12345678910111213141516171819202122232425262728293031323334353637 //设置暂停和恢复 //suspended设置为YES表示暂停，suspended设置为NO表示恢复 //暂停表示不继续执行队列中的下一个任务，暂停操作是可以恢复的 if (self.queue.isSuspended) &#123; self.queue.suspended = NO; &#125;else &#123; self.queue.suspended = YES; &#125; //取消队列里面的所有操作 //取消之后，当前正在执行的操作的下一个操作将不再执行，而且永远都不在执行，就像后面的所有任务都从队列里面移除了一样 //取消操作是不可以恢复的 [self.queue cancelAllOperations];---------自定义NSOperation取消操作---------------------------(void)main&#123; //耗时操作1 for (int i = 0; i&lt;1000; i++) &#123; NSLog(@"任务1-%d--%@",i,[NSThread currentThread]); &#125; NSLog(@"+++++++++++++++++++++++++++++++++"); //苹果官方建议，每当执行完一次耗时操作之后，就查看一下当前队列是否为取消状态，如果是，那么就直接退出 //好处是可以提高程序的性能 if (self.isCancelled) &#123; return; &#125; //耗时操作2 for (int i = 0; i&lt;1000; i++) &#123; NSLog(@"任务1-%d--%@",i,[NSThread currentThread]); &#125; NSLog(@"+++++++++++++++++++++++++++++++++");&#125; NSOperation实现线程间通信 123456789101112131415161718//1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.使用简便方法封装操作并添加到队列中 [queue addOperationWithBlock:^&#123; //3.在该block中下载图片 NSURL *url = [NSURL URLWithString:@"http://news.51sheyuan.com/uploads/allimg/111001/133442IB-2.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@"下载图片操作--%@",[NSThread currentThread]); //4.回到主线程刷新UI [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"刷新UI操作---%@",[NSThread currentThread]); &#125;]; &#125;]; 操作依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/02 综合案例- (void)download2&#123; NSLog(@"----"); //1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.封装操作下载图片1 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; //拿到图片数据 self.image1 = [UIImage imageWithData:data]; &#125;]; //3.封装操作下载图片2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://pic.58pic.com/58pic/13/87/82/27Q58PICYje_1024.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; //拿到图片数据 self.image2 = [UIImage imageWithData:data]; &#125;]; //4.合成图片 NSBlockOperation *combine = [NSBlockOperation blockOperationWithBlock:^&#123; //4.1 开启图形上下文 UIGraphicsBeginImageContext(CGSizeMake(200, 200)); //4.2 画image1 [self.image1 drawInRect:CGRectMake(0, 0, 200, 100)]; //4.3 画image2 [self.image2 drawInRect:CGRectMake(0, 100, 200, 100)]; //4.4 根据图形上下文拿到图片数据 UIImage *image = UIGraphicsGetImageFromCurrentImageContext();// NSLog(@"%@",image); //4.5 关闭图形上下文 UIGraphicsEndImageContext(); //7.回到主线程刷新UI [[NSOperationQueue mainQueue]addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"刷新UI---%@",[NSThread currentThread]); &#125;]; &#125;]; //5.设置操作依赖 [combine addDependency:op1]; [combine addDependency:op2]; //6.添加操作到队列中执行 [queue addOperation:op1]; [queue addOperation:op2]; [queue addOperation:combine]; &#125;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIApplication对象]]></title>
    <url>%2F2018%2F03%2F17%2FUIApplication%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[UIApplication单例 什么是UIApplication? UIApplication是兑现的应用程序象征，每一个应用都有自己的UIApplication对象，这个对象是系统自动帮我们创建的，它是一个单例对象。一个iOS程序启动后创建的第一个对象就是UIApplication对象，我们只能通过[UIApplication sharedApplication]获得这个单例对象，不能手动创建它 UIApplication作用（利用UIApplication对象能进行一些应用级别的操作） 可以设置应用程序图标右上角的红色提醒数字 可以设置程序联网指示器的可见性 可以设置应用程序的状态栏 可以进行应用之间的跳转 模仿UIApplication单例 要求 程序一启动就创建创建对象.创建的对象只能通过share的方式获取对象.不能够进行alloc 操作,当执行alloc时, 程序发生崩溃 代码实现 程序一启动时候就创建对象 12345678//当类被加载到内存的时候就会调用load的方法,它会比main优先调用static Persion *_instance;+(void)load&#123; 想要保存创建的对象, 要用成员属性,但是现在是类方法, 没有办法访问成员属性. 所以搞了一个static的静态变量进行保存 创建对象 _instance = [[self alloc] init];&#125; 保证调用alloc时会产生异常. 1234567891011121314//重写系统的是alloc方法+(instancetype)alloc&#123; 当调用alloc方法时,先查看一下_instance有没有值,如果已经有值的话,直接抛出异常. if(_instance)&#123; NSException *exception = [NSException exceptionWithName: @"NSInternalInconsistencyException" reason: @"There can only be one Persion instance." userInfo:nil]; 抛出异常 [exception raise]; &#125; 保持系统的做法. return [super alloc]; &#125; 通过share方式获取对象 123+(instancetype)sharePersion&#123; return _instance&#125; UIApplication功能 设置应用提醒数字 12345678//获取UIApplication对象UIApplication *ap = [UIApplication sharedApplication];//在设置之前, 要注册一个通知,从ios8之后,都要先注册一个通知对象.才能够接收到提醒.UIUserNotificationSettings *notice = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge categories:nil];//注册通知对象[ap registerUserNotificationSettings:notice];//设置提醒数字ap.applicationIconBadgeNumber = 10; 设置联网状态 1ap.networkActivityIndicatorVisible = YES; 设置状态栏 控制器管理状态栏 状态栏样式 1234//应用程序的状态栏,默认是交给控制器来管理的.控制器提供的方法,可以直接重写这个方法在控制器当中设置状态栏样式-(UIStatusBarStyle)preferredStatusBarStyle&#123; return UIStatusBarStyleLightContent;&#125; 隐藏状态栏 1234//隐藏状态栏,通过控制器的方式.同样实现方法:返回NO时为不隐藏返回YES时为显示-(BOOL)prefersStatusBarHidden&#123;return NO;&#125; 通过UIApplication来管理状态. 状态栏样式 1234//获取UIApplicationUIApplication *ap = [UIApplication sharedApplication];//设置状态栏样式.ap.statusBarStyle = UIStatusBarStyleLightContent; 隐藏状态栏 1234//获取UIApplicationUIApplication *ap = [UIApplication sharedApplication];//设置状态的隐藏ap.statusBarHidden = YES; 跳转网页,打电话,发短信 12345UIApplication *ap = [UIApplication sharedApplication];//URL:协议头://域名//应用程序通过协议头的类型,去打开相应的软件.NSURL *url =[NSURL URLWithString:@"http://www.baidu.com"];[ap openURL:url]; 12UIApplication *app = [UIApplication sharedApplication];[application openURL:[NSURL URLWithString:@"tel://10086"]]; 12UIApplication *app = [UIApplication sharedApplication];[app openURL:[NSURL URLWithString:@"sms://10086"]]; UIApplication代理 移动操作系统都有个致命的缺点 所有的移动操作系统都有个致命的缺点：app很容易受到打扰。 比如一个来电或者锁屏会导致app进入后台甚至被终止 还有很多其它类似的情况会导致app受到干扰，在app受到干扰时，会产生一些系统事件， 这时UIApplication会通知它的delegate对象，让delegate代理来处理这些系统事件 delegate可处理的事件 应用程序的生命周期事件(如程序启动和关闭) 系统事件(如来电) 内存警告 UIApplication代理 UIApplication会在程序一启动时候创建一个遵守UIApplicationDelegate代理. 这个就是我们程序一创建时的AppDelegate类.AppDelegate就是遵守了UIApplicationDelegate协议. 在这个类中很定义很多监听系统事件的方法.同时也定义了一些应用程序的生命周期方法. UIApplication代理方法 1234567891011121314151617181920212223242526//应用程序启动完成的时候调用- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSLog(@"%s",__func__); return YES;&#125;//当应用程序即将失去焦点的时候调用- (void)applicationWillResignActive:(UIApplication *)application &#123; NSLog(@"%s",__func__);&#125;//当应用程序完全进入后台的时候调用- (void)applicationDidEnterBackground:(UIApplication *)application&#123; NSLog(@"%s",__func__);&#125;//当应用程序即将进入前台的时候调用- (void)applicationWillEnterForeground:(UIApplication *)application &#123; NSLog(@"%s",__func__);&#125;//当应用程序完全获取焦点的时候调用//只有当一个应用程序完全获取到焦点,才能与用户交互.- (void)applicationDidBecomeActive:(UIApplication *)application &#123; NSLog(@"%s",__func__);&#125;//当应用程序即将关闭的时候调用- (void)applicationWillTerminate:(UIApplication *)application &#123; NSLog(@"%s",__func__);&#125; ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS项目常见文件]]></title>
    <url>%2F2018%2F03%2F17%2FiOS%E9%A1%B9%E7%9B%AE%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Xcode5和Xcode7的区别 Xcode7没有Frameworks文件夹，Xcode7内部会自动导入一些常见的框架. Xcode7多了LanuchScreen.xib，LanunchScreen是设置启动界面，而且可以确定模拟器或者真机的真实尺寸，如果没有设置，默认是iPhone4s的尺寸(320,480) Xcode7没有pch文件 Xcode5当中也有info.plist文件，只不过它的名字很长是工程的名称 LaunchScreen启动原理 会自动加载LanunchScreen是因为在Target当中置顶了Launch Screen file 如果没有设置启动图片，模拟器默认的尺寸大小是4s的尺寸大小 它的底层实现其实是把LanunchScreen上的东西生成一张图片，然后把这张图片设为程序的启动图片 info.plist文件 作用：info.plist当中保存着整个应用当中基本的配置。它是一个字典。 info.plist当中常见的key值： Bundle Name:应用程序的名称 Bundle version string,short:应用程序的版本，在开发当中都是迭代开放，苹果要求下一次提交的版本必须要比上一次提交的版本要高 Bundle Version:应用程序编译的版本 Bundle idertifier:应用程序标识符。保证应用程序的唯一性。 pch文件 作用 pch存放公用的宏 pch存放公用的头文件，分类的头文件 pch可以自定义log pch文件原理 会把pch里面所有的内容导入到每个文件中 配制pch文件 在项目Blud Setting当中找到perfix找到Precomplie prefix Header设为yes 设置完成后再进行prefix Header路径配制。路径从根层开始 自定义log 12345678910#ifdef DEBUG 调试阶段...表示宏里面的可变参数__VA_ARGS__函数里面可变参数#define XMGLog(...) NSLog(__VA_ARGS__)#else 发布阶段#define XMGLog(...)#endif pch文件注意点 注意pch会把它当中的所有内容导入到工程当中的所有文件，但如果工程当中有c语言文件的时候，它也会导入到c语言文件当中，这样会发生错误 解决办法:每一个OC文件都会定义一个 OBJC 宏,只要判断有没有定义这样一个宏,就能看出是不是C语言的文件,如果没有定义这样的宏, 那就不需要导入这些东西.就不会报错. ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS中代理使用]]></title>
    <url>%2F2018%2F03%2F01%2FiOS%E4%B8%AD%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[定义一份代理协议 协议名称的格式一般是：类名＋Delegate 比如UITableViewDelegate 设计代理的细节 一般都是@optional(让代理可以有选择的实现一些代理方法) 方法名一般都以类名开头 比如- (void)scrollViewDidScroll: 一般都需要将对象本身传出去 比如tableview的代理方法都会把tableview本身传出去 必须要遵守NSObject协议(基协议) 比如@protocol CellDelegate &lt;NSObject&gt; 声明一个代理属性 代理的类型格式:id &lt;协议&gt; delegate 1@property (nonatomic,weak) id&lt;CellDelegate&gt; delegate; 设置代理对象 代理对象遵守协议，实现协议里面相应的方法 当控件内部发生一些事情，就可以调用代理的代理方法通知代理 如果代理方法是@optional,那么需要判断方法是否有实现，直接调用可能会报错 123if ([self.delegate respondsToSelector:@selector(wineCellDidClickPlusButton:)]) &#123; [self.delegate wineCellDidClickPlusButton:self];&#125;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的通知NSNotificationCenter]]></title>
    <url>%2F2018%2F03%2F01%2FiOS%E4%B8%AD%E7%9A%84%E9%80%9A%E7%9F%A5NSNotificationCenter%2F</url>
    <content type="text"><![CDATA[通知中心(NSNotificationCenter)是在程序内部提供的一种广播机制。把接收到的消息，根据内部的消息转发表，将消息转发给需要的对象。 通知使用分为两步，第一步：在需要使用的地方注册要观察的通知，第二部：在某地方发送通知。(发送的通知可以是我们自定义的通知，也可以是系统的通知) Demo Person.h 123456789101112131415//// Person.h// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *name;@end ​ Person.m 123456789101112131415161718//// Person.m// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import "Person.h"@implementation Person-(void)getNew:(NSNotification *)note&#123; NSLog(@"%@接收到了%@发布的%@通知,通知内容是%@",self.name,[note.object name],note.name,note.userInfo);&#125;@end Company.h 123456789101112131415//// Company.h// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Company : NSObject@property (nonatomic,copy) NSString *name;@end Company.m 12345678910111213//// Company.m// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import "Company.h"@implementation Company@end ViewController.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// ViewController.m// 通知-demo//// Created by 武 on 18/2/28.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Person.h"#import "Company.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Company *com1 = [[Company alloc]init]; com1.name = @"Tencent"; Company *com2 = [[Company alloc]init]; com2.name = @"Sina"; Person *p1 = [[Person alloc]init]; p1.name = @"张三"; Person *p2 = [[Person alloc]init]; p2.name = @"李四"; Person *p3 = [[Person alloc]init]; p3.name = @"王五"; /***模拟通知**/ //监听通知 [[NSNotificationCenter defaultCenter] addObserver:p1 selector:@selector(getNew:) name:nil object:nil]; //发布通知 NSNotification *note = [NSNotification notificationWithName:@"军事新闻" object:com1 userInfo:@&#123;@"title":@"xxxxxxx"&#125;]; [[NSNotificationCenter defaultCenter] postNotification:note]; //移除通知 [[NSNotificationCenter defaultCenter]removeObserver:p1];&#125;@end 首先p1张三注册监听，它监听的通知name和object为nil说明它可以监听任何对象发布的任意通知,然后com1发布了一条名称为军事新闻内容为xxxxxxx的通知，张三一旦监听到这条通知就会执行getNew这个方法，这个方法携带了通知的发布者，通知的名称通知的内容等信息。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView]]></title>
    <url>%2F2018%2F01%2F29%2FUITableView%2F</url>
    <content type="text"><![CDATA[简介从字面可以看出它是一个表格UI控件，在iOS开发中UITableView可以说是使用最广泛的控件，我们在使用软件中到处可以看到它的影子，例如QQ以及微信的联系人界面都是UITableView. UITableView有两种显示风格，一个是分组样式，一个是不分组样式。如下图 不分组样式 分组样式 可以看到在UITableView中数据只有行的概念，并没有列的概念，因为在手机操作中显示列是不利于操作的。 UITableView中每行数据都是一个UITableViewCell在这个控件中为了显示更多的信息，iOS已经在其内部设置了多个子控件供使用。一个contentView座位其他元素的父控件，两个UILabel控件（textLabel,detailTextLabel）,一个imageView，分别用于容器、显示内容、详情和图片。 这些控件不一定要全部使用，具体操作时可以通过UITableViewCellStyle进行设置，它是一个枚举表示UITableView的排列方式。 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 左侧显示textLabel（不显示detailTextLabel），imageView可选（显示在最左边） UITableViewCellStyleValue1, // 左侧显示textLabel、右侧显示detailTextLabel（默认蓝色），imageView可选（显示在最左边） UITableViewCellStyleValue2, // 左侧依次显示textLabel(默认蓝色)和detailTextLabel，imageView可选（显示在最左边） UITableViewCellStyleSubtitle // 左上方显示textLabel，左下方显示detailTextLabel（默认灰色）,imageView可选（显示在最左边）&#125;; 数据源由于iOS是遵循MVC模式设计的，很多操作都是通过代理和外界沟通的，但对于数据源控件除了代理还有一个数据源属性，通过它和外界进行数据交互。 对于UITableView设置完dataSource后需要实现UITableViewDataSource协议，在这个协议中定义了多种 数据操作方法。 简单示例 新建一个person模型类 person.h 12345678910111213141516171819202122//// Person.h// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,copy) NSString *firstName;@property (nonatomic,copy) NSString *lastName;@property (nonatomic,copy) NSString *phoneNumber;- (Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber;- (NSString *)getName;+ (Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber;@end person.m 1234567891011121314151617181920212223242526272829303132//// Person.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "Person.h"@implementation Person-(Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber&#123; if (self=[super init]) &#123; self.firstName = firstName; self.lastName = lastName; self.phoneNumber = phoneNumber; &#125; return self;&#125;-(NSString *)getName&#123; return [NSString stringWithFormat:@"%@-%@",_lastName,_firstName];&#125;+(Person *)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName andPhoneNumber:(NSString *)phoneNumber&#123; return [[self alloc]initWithFirstName:firstName andLastName:lastName andPhoneNumber:phoneNumber];&#125;@end 新建PersonGroup模型类 PersonGroup.h 123456789101112131415161718192021//// PersonGroup.h// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface PersonGroup : NSObject@property (nonatomic,copy) NSString *name;@property (nonatomic,copy) NSString *detail;@property (nonatomic,strong) NSMutableArray *persons;-(PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons;+(PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons;@end PersonGroup.m 123456789101112131415161718192021222324252627//// PersonGroup.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "PersonGroup.h"@implementation PersonGroup- (PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons&#123; if (self=[super init]) &#123; self.name = name; self.detail = detail; self.persons = persons; &#125; return self;&#125;+ (PersonGroup *)initWithName:(NSString *)name andDetail:(NSString *)detail andPerson:(NSMutableArray *)persons&#123; return [[self alloc]initWithName:name andDetail:detail andPerson:persons];&#125;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//// ViewController.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Person.h"#import "PersonGroup.h"@interface ViewController ()&lt;UITableViewDataSource&gt;&#123; UITableView *_tableView; NSMutableArray *_persondata;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self initPersonData]; //创建一个分组样式的tableview _tableView = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStyleGrouped]; //设置数据源 _tableView.dataSource = self; [self.view addSubview:_tableView];&#125;/** 加载数据 */- (void)initPersonData&#123; _persondata = [[NSMutableArray alloc]init]; Person *peron1 = [Person initWithFirstName:@"zhang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron2 = [Person initWithFirstName:@"zhang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron3 = [Person initWithFirstName:@"zhang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray1 = [PersonGroup initWithName:@"Z" andDetail:@"张姓" andPersons:[NSMutableArray arrayWithObjects:peron1,peron2,peron3, nil]]; [_persondata addObject:pArray1]; Person *peron4 = [Person initWithFirstName:@"li" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron5 = [Person initWithFirstName:@"li" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron6 = [Person initWithFirstName:@"li" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray2 = [PersonGroup initWithName:@"L" andDetail:@"李姓" andPersons:[NSMutableArray arrayWithObjects:peron4,peron5,peron6, nil]]; [_persondata addObject:pArray2]; Person *peron7 = [Person initWithFirstName:@"wang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron8 = [Person initWithFirstName:@"wang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron9 = [Person initWithFirstName:@"wang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray3 = [PersonGroup initWithName:@"W" andDetail:@"王姓" andPersons:[NSMutableArray arrayWithObjects:peron7,peron8,peron9, nil]]; [_persondata addObject:pArray3];&#125;#pragma mark 数据源方法/** @return 共多少组 */- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return _persondata.count;&#125;/** @param section 那一组 @return 多少行 */- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.persons.count;&#125;/**设置每一行cell数据 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; UITableViewCell *cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil]; cell.textLabel.text = [person getName]; cell.detailTextLabel.text = person.phoneNumber; return cell;&#125;/** @return 每一组的头标题 */-(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.name;&#125;/** @return 每一组的尾标题 */- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.detail;&#125;/** 每组的标题索引 */- (NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; NSMutableArray *indexs = [[NSMutableArray alloc]init]; for (PersonGroup *group in _persondata) &#123; [indexs addObject:group.name]; &#125; return indexs;&#125;@end 运行结果 ​ 方法执行顺序为计算分组数(不写此方法默认为1组)—&gt;计算每组的行数—&gt;生成分组索引—&gt;生成单元格(依次生成所有组的单元格)，生成单元格并不是一次全部生成，而是只会生成显示在界面上的单元格。 代理 设置行高 123456789101112131415161718#pragma mark - 代理方法#pragma mark 设置分组标题内容高度-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; if(section==0)&#123; return 50; &#125; return 40;&#125;#pragma mark 设置每行高度（每行高度可以不一样）-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 45;&#125;#pragma mark 设置尾部说明内容高度-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 40;&#125; 监听点击事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//// ViewController.m// UITableView简单示例//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Person.h"#import "PersonGroup.h"@interface ViewController ()&lt;UITableViewDataSource,UITableViewDelegate,UIAlertViewDelegate&gt;&#123; UITableView *_tableView; NSMutableArray *_persondata; NSIndexPath *_selectIndexPath;//当前选中的组和行&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self initPersonData]; //创建一个分组样式的tableview _tableView = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStyleGrouped]; //设置数据源 _tableView.dataSource = self; _tableView.delegate = self; [self.view addSubview:_tableView];&#125;/** 加载数据 */- (void)initPersonData&#123; _persondata = [[NSMutableArray alloc]init]; Person *peron1 = [Person initWithFirstName:@"zhang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron2 = [Person initWithFirstName:@"zhang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron3 = [Person initWithFirstName:@"zhang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray1 = [PersonGroup initWithName:@"Z" andDetail:@"张姓" andPersons:[NSMutableArray arrayWithObjects:peron1,peron2,peron3, nil]]; [_persondata addObject:pArray1]; Person *peron4 = [Person initWithFirstName:@"li" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron5 = [Person initWithFirstName:@"li" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron6 = [Person initWithFirstName:@"li" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray2 = [PersonGroup initWithName:@"L" andDetail:@"李姓" andPersons:[NSMutableArray arrayWithObjects:peron4,peron5,peron6, nil]]; [_persondata addObject:pArray2]; Person *peron7 = [Person initWithFirstName:@"wang" andLastName:@"san" andPhoneNumber:@"1888888888"]; Person *peron8 = [Person initWithFirstName:@"wang" andLastName:@"si" andPhoneNumber:@"1777777777"]; Person *peron9 = [Person initWithFirstName:@"wang" andLastName:@"wu" andPhoneNumber:@"1666666666"]; PersonGroup *pArray3 = [PersonGroup initWithName:@"W" andDetail:@"王姓" andPersons:[NSMutableArray arrayWithObjects:peron7,peron8,peron9, nil]]; [_persondata addObject:pArray3];&#125;#pragma mark 数据源方法/** @return 共多少组 */- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return _persondata.count;&#125;/** @param section 那一组 @return 多少行 */- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.persons.count;&#125;/**设置每一行cell数据 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; UITableViewCell *cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil]; cell.textLabel.text = [person getName]; cell.detailTextLabel.text = person.phoneNumber; return cell;&#125;/** @return 每一组的头标题 */-(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.name;&#125;/** @return 每一组的尾标题 */- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section&#123; PersonGroup *group = _persondata[section]; return group.detail;&#125;/** 每组的标题索引 */- (NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; NSMutableArray *indexs = [[NSMutableArray alloc]init]; for (PersonGroup *group in _persondata) &#123; [indexs addObject:group.name]; &#125; return indexs;&#125;#pragma mark 代理方法- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; if (section==0) &#123; return 50; &#125; return 40;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 45;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 40;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; _selectIndexPath = indexPath; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; //创建弹出窗口 UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"窗口标题" message:[person getName] delegate:self cancelButtonTitle:@"完成" otherButtonTitles:@"OK", nil]; alert.alertViewStyle = UIAlertViewStylePlainTextInput;//设置窗口内容样式 UITextField *textField = [alert textFieldAtIndex:0];//取得文本框 textField.text = person.phoneNumber;//设置文本框内容为电话 [alert show];//显示弹出窗口&#125;#pragma mark alert代理方法- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //当点击了第二个按钮（OK） if (buttonIndex==1) &#123; UITextField *textField = [alertView textFieldAtIndex:0]; //修改模型数据 PersonGroup *group = _persondata[_selectIndexPath.section]; Person *person = group.persons[_selectIndexPath.row]; person.phoneNumber = textField.text; //[_tableView reloadData];//刷新表格 这种方式不可取需要局部刷新 NSArray *indexPaths=@[_selectIndexPath];//需要刷新的单元格的组、行 [_tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationLeft];//最后一个参数代表更新时使用那种动画 &#125;&#125;@end 注意修改数据后刷新表格尽量使用局部刷新 性能优化UITableView中的单元格cell时再显示到用户可视区域后创建的，那么如果用户往下滚动就会继续创建显示在屏幕上的单元格，如果用户向上滚动返回到查看过的内容时同样会创建之前已经创建过的单元格，如此一来即使UITableView的内容不是太多，如果用户反复的上下滚动，内存也会瞬间飙升，更何况很多时候UITableView的内容是很多的。 无限滚动UIScrollView是利用有限的UIImageView动态切换其内容来尽可能减少资源占用。同样的，在UITableView中也可以采用类似的方式，只是这时我们不是在滚动到指定位置后更改滚动的位置而是要将当前没有显示的Cell重新显示在将要显示的Cell的位置然后更新其内容。原因就是UITableView中的Cell结构布局可能是不同的，通过重新定位是不可取的，而是需要重用已经不再界面显示的已创建过的Cell. UITableView内部有一个缓存池，初始化的时候使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString \*)方法指定一个可重用表示，就可以将这个cell放到缓存池。然后在使用的时候使用指定的标识符取缓存池中取得对应的cell然后修改cell内容即可。 123456789101112131415161718192021/**设置每一行cell数据 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; PersonGroup *group = _persondata[indexPath.section]; Person *person = group.persons[indexPath.row]; //方法调用十分频繁，声明成静态变量有利于性能优化 static NSString *ID = @"person"; //先从缓存中取标识符为ID的cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; //如果缓存池中没有标识符为ID的cell再新建一个标识符为ID的cell if (cell==nil) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; &#125; cell.textLabel.text = [person getName]; cell.detailTextLabel.text = person.phoneNumber; return cell;&#125; 自定义TableViewCell(仿照微博)文件结构图 创建微博模型类 Status.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//// Status.h// 自定义不等高cell//// Created by 武 on 18/1/25.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface Status : NSObject/** 图像 */@property (nonatomic,copy) NSString *icon;/** 昵称 */@property (nonatomic,copy) NSString *name;/** 正文内容 */@property (nonatomic,copy) NSString *text;/** VIP */@property (nonatomic,assign,getter=isVip) BOOL vip;/** 配图 */@property (nonatomic,copy) NSString *picture;/** 图像的frame */@property (nonatomic,assign) CGRect iconFrame;/** 昵称的frame */@property (nonatomic,assign) CGRect nameFrame;/** vip的frame */@property (nonatomic,assign) CGRect vipFrame;/** 正文frame */@property (nonatomic,assign) CGRect textFrame;/** 配图的frame */@property (nonatomic,assign) CGRect pictureFrame;/** cell的高度 */@property (nonatomic,assign) CGFloat cellHeight;@end Status.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//// Status.m// 自定义不等高cell//// Created by 武 on 18/1/25.// Copyright © 2018年 com. All rights reserved.//#import "Status.h"@implementation Status-(CGFloat)cellHeight&#123; if (_cellHeight == 0 ) &#123; CGFloat space = 10; //图像 CGFloat iconX = space; CGFloat iconY = space; CGFloat iconWH = 30; self.iconFrame = CGRectMake(iconX, iconY, iconWH, iconWH); //昵称 CGFloat nameX = CGRectGetMaxX(self.iconFrame)+space; CGFloat nameY = iconY; NSDictionary *nameAtt = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:17]&#125;; //计算昵称文字的尺寸 CGSize nameSize = [self.name sizeWithAttributes:nameAtt]; CGFloat nameW = nameSize.width; CGFloat nameH = nameSize.height; self.nameFrame = CGRectMake(nameX, nameY, nameW, nameH); //vip if (self.isVip) &#123; CGFloat vipX = CGRectGetMaxX(self.nameFrame)+space; CGFloat vipW = 14; CGFloat vipH = nameH; CGFloat vipY = nameY; self.vipFrame = CGRectMake(vipX, vipY, vipW, vipH); &#125; //正文 CGFloat textX = iconX; CGFloat textY = CGRectGetMaxY(self.iconFrame)+space; CGFloat textW = [UIScreen mainScreen].bounds.size.width-2*space; NSDictionary *textAtt = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125;; //最大宽度是textW,宽度不限制 CGSize textSize = CGSizeMake(textW, MAXFLOAT); CGFloat textH = [self.text boundingRectWithSize:textSize options:NSStringDrawingUsesLineFragmentOrigin attributes:textAtt context:nil].size.height; self.textFrame = CGRectMake(textX, textY, textW, textH); //配图 if (self.picture) &#123; CGFloat pictureWH = 100; CGFloat pictureX = iconX; CGFloat pictureY = CGRectGetMaxY(self.textFrame)+space; self.pictureFrame = CGRectMake(pictureX, pictureY, pictureWH, pictureWH); _cellHeight = CGRectGetMaxY(self.pictureFrame)+space; &#125;else &#123; _cellHeight = CGRectGetMaxY(self.textFrame)+space; &#125; &#125; return _cellHeight;&#125;@end ​ 自定义cell必须继承UITableViewCell类 StatusCell.h 123456789101112131415//// StatusCell.h// 自定义不等高cell//// Created by 武 on 18/1/26.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@class Status;@interface StatusCell : UITableViewCell/** 微博模型 */@property (nonatomic,strong) Status *status;@end StatusCell.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// StatusCell.m// 自定义不等高cell//// Created by 武 on 18/1/26.// Copyright © 2018年 com. All rights reserved.//#import "StatusCell.h"#import "Status.h"@interface StatusCell()/** 图像 */@property (nonatomic,weak) UIImageView *iconImageView;/** 昵称 */@property (nonatomic,weak) UILabel *nameLabel;/** vip */@property (nonatomic,weak) UIImageView *vipImageView;/** 正文 */@property (nonatomic,weak) UILabel *text_Label;/** 配图 */@property (nonatomic,weak) UIImageView *pictureImageView;@end@implementation StatusCell/** 添加子控件的原则：把所有可能显示的子控件都先添加进去 */-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; //图像 UIImageView *iconImageView = [[UIImageView alloc]init]; [self.contentView addSubview:iconImageView]; self.iconImageView = iconImageView; //配图 UIImageView *pictureImageView = [[UIImageView alloc]init]; [self.contentView addSubview:pictureImageView]; self.pictureImageView = pictureImageView; //vip UIImageView *vipImageView = [[UIImageView alloc]init]; vipImageView.contentMode = UIViewContentModeCenter; vipImageView.image = [UIImage imageNamed:@"vip"]; [self.contentView addSubview:vipImageView]; self.vipImageView = vipImageView; //昵称 UILabel *nameLabel = [[UILabel alloc]init]; nameLabel.font = [UIFont systemFontOfSize:14]; [self.contentView addSubview:nameLabel]; self.nameLabel = nameLabel; //正文 UILabel *text_Label = [[UILabel alloc]init]; text_Label.font = [UIFont systemFontOfSize:14]; text_Label.numberOfLines = 0; [self.contentView addSubview:text_Label]; self.text_Label = text_Label; &#125; return self;&#125;/* 设置子控件的数据 */- (void)setStatus:(Status *)status&#123; _status = status; self.iconImageView.image = [UIImage imageNamed:status.icon]; self.nameLabel.text = status.name; if (status.isVip) &#123; self.nameLabel.textColor = [UIColor orangeColor]; self.vipImageView.hidden = NO; &#125;else &#123; self.vipImageView.hidden = YES; self.nameLabel.textColor = [UIColor blackColor]; &#125; self.text_Label.text = status.text; if (status.picture) &#123; self.pictureImageView.hidden = NO; self.pictureImageView.image = [UIImage imageNamed:status.picture]; &#125;else &#123; self.pictureImageView.hidden = YES; &#125; self.iconImageView.frame = self.status.iconFrame; self.nameLabel.frame = self.status.nameFrame; self.vipImageView.frame = self.status.vipFrame; self.text_Label.frame = self.status.textFrame; self.pictureImageView.frame = self.status.pictureFrame;&#125;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// ViewController.m// 自定义不等高cell//// Created by 武 on 18/1/25.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "Status.h"#import "MJExtension.h"#import "StatusCell.h"@interface ViewController ()@property (nonatomic,strong) NSArray *statues;@end@implementation ViewController-(NSArray *)statues&#123; if (_statues==nil) &#123; _statues = [Status mj_objectArrayWithFilename:@"statuses.plist"]; &#125; return _statues;&#125;NSString *ID = @"status";- (void)viewDidLoad &#123; [super viewDidLoad]; //注册cell [self.tableView registerClass:[StatusCell class] forCellReuseIdentifier:ID];&#125;#pragma mark 数据源方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.statues.count;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; StatusCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; cell.status = self.statues[indexPath.row]; return cell;&#125;#pragma mark 代理方法- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; Status *status = self.statues[indexPath.row]; return status.cellHeight;&#125;- (BOOL)prefersStatusBarHidden&#123; return YES;&#125;@end TableView数据刷新 UITableView的刷新方法 12345 (void)reloadData;//刷新整个表格。- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);//刷新指定的分组和行。- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);//刷新指定的分组。- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//删除时刷新指定的行数据。- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//添加时刷新指定的行数据。 全局刷新 示例说明在Main.storyboard中添加一个UIView里面包含3个按钮分别是添加、更新、删除。下面再添加一个TableView。 如下图 模型类Wine.h 12345678910111213141516171819202122//// Wine.h// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Wine : NSObject/** 图标 */@property (nonatomic,copy) NSString *image;/** 价格 */@property (nonatomic,copy) NSString *money;/** 名称 */@property (nonatomic,copy) NSString *name;@end 自定义cell-WineCell.h 12345678910111213141516//// WineCell.h// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@class Wine;@interface WineCell : UITableViewCell/** 模型属性 */@property (nonatomic,strong) Wine *wine;@end WineCell.m 12345678910111213141516171819//// WineCell.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "WineCell.h"#import "Wine.h"@implementation WineCell-(void)setWine:(Wine *)wine&#123; _wine = wine; self.textLabel.text = wine.name; self.imageView.image = [UIImage imageNamed:wine.image]; self.detailTextLabel.text = [NSString stringWithFormat:@"¥%@",wine.money];&#125;@end ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// ViewController.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "MJExtension.h"#import "Wine.h"#import "WineCell.h"@interface ViewController ()&lt;UITableViewDataSource&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;/** 所有的数据 */@property (nonatomic,strong)NSMutableArray *wineArray;@end@implementation ViewController/** 从plist文件加载数据，使用MJExtension框架 */-(NSMutableArray *)wineArray&#123; if (_wineArray==nil) &#123; _wineArray = [Wine mj_objectArrayWithFilename:@"wine.plist"]; &#125; return _wineArray;&#125;/** 点击添加 */- (IBAction)add &#123; //新建一个模型 Wine *wine = [[Wine alloc]init]; wine.image = @"newWine"; wine.money = @"999.9"; wine.name = @"茅台"; // [self.wineArray addObject:wine];//添加到表格最后 [self.wineArray insertObject:wine atIndex:0];//添加到表格第一位 //数据发生变化，刷新数据（全局刷新） [self.tableView reloadData];&#125;/** 点击删除 */- (IBAction)delete &#123; // 删除模型 [self.wineArray removeObjectAtIndex:0]; [self.wineArray removeObjectAtIndex:0]; //全局刷新 [self.tableView reloadData];&#125;/** 点击更新 */- (IBAction)update &#123; // 更新模型，把价格改为100 Wine *wine = self.wineArray[0]; wine.money = @"100"; // 全局刷新 [self.tableView reloadData];&#125;#pragma mark 数据源方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.wineArray.count;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @"wine"; WineCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell==nil) &#123; cell = [[WineCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; &#125; cell.wine = _wineArray[indexPath.row]; return cell;&#125;@end 运行如下 局部刷新（操作那一行数据刷新哪一行） 修改add、update、delete三个方法的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (IBAction)add &#123; // 修改模型 XMGWine *wine = [[XMGWine alloc] init]; wine.image = @"newWine"; wine.money = @"56"; wine.name = @"杏花村"; [self.wineArray insertObject:wine atIndex:0]; // 这是全局刷新// [self.tableView reloadData]; // 局部刷新 NSArray *indexPaths = @[ [NSIndexPath indexPathForRow:0 inSection:0] ]; [self.tableView insertRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationRight];&#125;- (IBAction)remove &#123; // 修改模型 [self.wineArray removeObjectAtIndex:0]; [self.wineArray removeObjectAtIndex:0]; // 局部刷新 NSArray *indexPaths = @[ [NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0], ]; [self.tableView deleteRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationMiddle]; // 这是全局刷新// [self.tableView reloadData];&#125;- (IBAction)update &#123; // 修改模型 XMGWine *wine = self.wineArray[0]; wine.money = @"100"; XMGWine *wine2 = self.wineArray[1]; wine2.name = @"呵呵"; // 局部刷新 NSArray *indexPaths = @[ [NSIndexPath indexPathForRow:0 inSection:0], [NSIndexPath indexPathForRow:1 inSection:0] ]; [self.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationLeft];&#125; 左滑删除12345678910/** 只要实现这个方法，就拥有左滑删除功能 点击左滑出现的Delete按钮会调用这个 */-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@&quot;commitEditingStyle--&quot;); [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];//局部删除删除&#125; UITableViewRowAction 1234567891011121314//左滑出现什么按钮- (NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewRowAction *action = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;关注&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; self.tableView.editing = NO; &#125;]; UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@&quot;删除&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; &#125;]; return @[action,action1];&#125; 编辑模式12345- (IBAction)remove&#123; //进入编辑模式，点击删除按钮取反 [self.tableView setEditing:!self.tableView.isEditing animated:YES];&#125; 自定义批量删除在cell里面添加一个打勾的UIImageView的控件并设置尺寸该控件选择的时候显示，默认隐藏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// WineCell.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "WineCell.h"#import "Wine.h"@interface WineCell()/** 打钩控件 */@property (nonatomic,weak) UIImageView *checkedImageView;@end@implementation WineCell/** 初始化控件 */- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; //添加打勾控件 UIImageView *checkImageView = [[UIImageView alloc]init]; checkImageView.hidden = YES; checkImageView.image = [UIImage imageNamed:@"check"]; [self.contentView addSubview:checkImageView]; self.checkedImageView = checkImageView; &#125;; return self;&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; //设置打勾控件的位置和尺寸 CGFloat WH = 24; CGFloat X = self.contentView.frame.size.width - WH - 10; CGFloat Y = (self.contentView.frame.size.height-WH)*0.5; self.checkedImageView.frame = CGRectMake(X, Y, WH, WH); //调整cell textLabel的宽度 CGRect frame = self.textLabel.frame; frame.size.width = self.contentView.frame.size.width-WH-20-self.textLabel.frame.origin.x; self.textLabel.frame = frame;&#125;-(void)setWine:(Wine *)wine&#123; _wine = wine; self.textLabel.text = wine.name; self.imageView.image = [UIImage imageNamed:wine.image]; self.detailTextLabel.text = [NSString stringWithFormat:@"¥%@",wine.money]; //根据模型的checked属性确定打勾控件显示还是隐藏 if (wine.isChecked) &#123; self.checkedImageView.hidden = NO; &#125;else &#123; self.checkedImageView.hidden = YES; &#125;&#125;@end 在模型类Wine.h里添加一个BOOL属性记录打勾控件的状态 1234/** 记录打勾控件的状态 */@property (nonatomic,assign,getter=isChecked) BOOL checked; ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// ViewController.m// 全局刷新//// Created by 武 on 18/2/1.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#import "MJExtension.h"#import "Wine.h"#import "WineCell.h"@interface ViewController ()&lt;UITableViewDataSource,UITableViewDelegate&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;/** 所有的数据 */@property (nonatomic,strong)NSMutableArray *wineArray;/** 记录所有选中行的索引 */@property (nonatomic,strong)NSMutableArray *selectedIndexPath;@end@implementation ViewController- (NSMutableArray *)selectedIndexPath&#123; if (!_selectedIndexPath) &#123; _selectedIndexPath = [NSMutableArray array]; &#125; return _selectedIndexPath;&#125;- (IBAction)remove &#123; //进入编辑模式，点击删除按钮取反 //[self.tableView setEditing:!self.tableView.isEditing animated:YES]; //获取要删除的所有模型 NSMutableArray *deleteWine = [NSMutableArray array]; for (NSIndexPath *indexPath in self.selectedIndexPath) &#123; [deleteWine addObject:self.wineArray[indexPath.row]]; &#125; //删除模型 [self.wineArray removeObjectsInArray:deleteWine]; //刷新表格 [self.tableView deleteRowsAtIndexPaths:self.selectedIndexPath withRowAnimation:UITableViewRowAnimationAutomatic]; //注意操作一次必须清空数组，要不然会数组角标越界 [self.selectedIndexPath removeAllObjects];&#125;/** 从plist文件加载数据，使用MJExtension框架 */-(NSMutableArray *)wineArray&#123; if (_wineArray==nil) &#123; _wineArray = [Wine mj_objectArrayWithFilename:@"wine.plist"]; &#125; return _wineArray;&#125; #pragma mark 数据源方法 (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return self.wineArray.count;} -(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ static NSString *ID = @&quot;wine&quot;; WineCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell==nil) { cell = [[WineCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; } cell.wine = _wineArray[indexPath.row]; return cell; } #pragma mark - 代理方法/* 只要实现这个方法，就拥有左滑删除功能 点击左滑出现的Delete按钮会调用这个 /-(void)tableView:(UITableView )tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath )indexPath{ NSLog(@&quot;commitEditingStyle--&quot;); [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];//局部删除删除 } (NSArray )tableView:(UITableView )tableView editActionsForRowAtIndexPath:(NSIndexPath )indexPath{ UITableViewRowAction action = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@”关注” handler:^(UITableViewRowAction _Nonnull action, NSIndexPath _Nonnull indexPath) { self.tableView.editing = NO; }]; UITableViewRowAction action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@”删除” handler:^(UITableViewRowAction _Nonnull action, NSIndexPath * _Nonnull indexPath) { [self.wineArray removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; }]; return @[action,action1];}//选择那一行的操作 (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath{ //修改模型 Wine *wine = self.wineArray[indexPath.row]; if (wine.isChecked) {//之前是打勾的就取反 wine.checked = NO; [self.selectedIndexPath removeObject:indexPath]; }else {//之前不是打勾的，现在打勾 wine.checked = YES; [self.selectedIndexPath addObject:indexPath]; } //局部刷新表格 [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];}@end``` 运行效果 ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView]]></title>
    <url>%2F2018%2F01%2F29%2FUIScrollView%2F</url>
    <content type="text"><![CDATA[简介UIScrollView是UIView的子类，这是一个可以处理滚动操作的UI控件在开发过程中使用很频繁。 属性123456789101112131415@property(nonatomic) CGPoint contentOffset;//内容偏移量，当前显示的内容得顶点相对此控件顶点x,y轴之间的距离，默认为CGPointZero@property(nonatomic) CGSize contentSize;//控件内容大小，不一定在显示区域，如果这个属性不设置，此控件将无法滚动，默认为CGSizeZero;@property(nonatomic) UIEdgeInsets contentInset;//控件四周边距，类似于css中的margin，注意边距不座位其内容的一部分，默认为UIEdgeInsertZero;@property(nonatomic,assign) id&lt;UIScrollViewDelegate&gt; delegate; //控件代理，一般用于事件监听，在iOS中多数控件都是通过代理来进行事件监听的@property(nonatomic) BOOL bounces;//启用弹簧效果，启用弹簧效果后拖动到边缘可以看到内容后面的背景，默认设置为YES@property(nonatomic,getter=isPagingEnabled)BOOL pagingEnabled;//是否分页，如果分页的话每次左右拖动的距离只屏幕宽度的整倍数，默认设置为NO@property(nonatomic,getter=isScrollEnabled)BOOL scrollEnabled;//是否启用滚动，默认也YES@property(nonatomic) BOOL showsHorizontalScrollIndicator;//是否显示横向滚动条，默认为YES@property(nonatomic) BOOL showsVerticalScrollIndicator;//是否显示纵向滚动条，默认为YES@property(nonatomic) CGFloat minimumZoomScale;//最小缩放倍数，默认为1.0@property(nonatomic) CGFloat maximumZoomScale;//最大缩放倍数(注意只有maximumZoomScale大于minimumZoomScale才有可能缩放)默认为1.0@property(nonatomic,readonly,getter= isTracking)BOOL tracking;//状态是否被追踪，手指按下去并且还没有拖动的时候是YES，其他情况均为NO@property(nonatomic,readonly,getter= isDragging)BOOL dragging;//判断状态是否被拖拽@property(nonatomic,readonly,getter=isDecelerating)BOOL decelerating;//判断状态是否减速@property(nonatomic,readonly,getter=isZomming)BOOL zomming;//判断状态是否缩放 方法12- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;//设置滚动位置，第二个参数表示是否启用动画效果- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;//滚动并显示指定区域的内容，第二个参数表示是否启用动画效果 代理方法12345678- (void)scrollViewDidScroll:(UIScrollView *)scrollView;//滚动事件方法，滚动过程中会一直循环执行- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;//开始拖拽事件- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;//拖拽操作完成事件方法- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;//即将停止滚动事件方法（拖拽松开后开始减速时执行）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;//滚动停止事件方法（滚动过程中减速停止后执行）- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view NS_AVAILABLE_IOS(3_2);//开始缩放事件方法- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2);//缩放操作完成事件方法- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;//返回缩放视图，注意只有实现这个代理方法才能进行缩放，此方法返回需要缩放的视图 简单示例 ViewController.h 1234567891011121314//// ViewController.h// UIScrollView-1//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController @property (nonatomic,strong) UIScrollView *scrollview;@property (nonatomic,strong) UIImageView *imageView;@end ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//// ViewController.m// UIScrollView-1//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"//实现UIScrollView代理@interface ViewController ()&lt;UIScrollViewDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //添加scrollview控件 //注意UIScreen代表当前屏幕对象，applicationFrame是当前屏幕内容区域 _scrollview = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].applicationFrame]; _scrollview.contentMode = UIViewContentModeScaleToFill; [self.view addSubview:_scrollview]; //添加图片控件 UIImage *image = [UIImage imageNamed:@"timg"]; _imageView = [[UIImageView alloc]initWithImage:image]; [_scrollview addSubview:_imageView]; //contentSize必须设置，否则无法滚动，当前设置为图片大小 _scrollview.contentSize = _imageView.frame.size; //实现缩放：maxinumZoomScale必须大于minimumZoomScale同时实现viewForZoomingInScrollView方法 _scrollview.minimumZoomScale = 0.6; _scrollview.maximumZoomScale = 3.0; //设置代理为viewController _scrollview.delegate = self; //边距，不属于内容部分，内容坐标（0，0）指的是内容的左上角不包括边界 //_scrollView.contentInset=UIEdgeInsetsMake(10, 20, 10, 20); //显示滚动内容的指定位置 //_scrollView.contentOffset=CGPointMake(10, 0); //隐藏滚动条 _scrollview.showsHorizontalScrollIndicator = NO; _scrollview.showsVerticalScrollIndicator = NO; //禁用弹簧效果 //_scrollView.bounces=NO;&#125;#pragma mark 代理方法- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; return _imageView;&#125;- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewWillBeginDecelerating");&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewDidEndDecelerating");&#125;-(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; NSLog(@"scrollViewWillBeginDragging");&#125;-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@"scrollViewDidEndDragging");&#125;-(void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view&#123; NSLog(@"scrollViewWillBeginZooming");&#125;-(void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale&#123; NSLog(@"scrollViewDidEndZooming");&#125;#pragma mark 当图片小于屏幕宽高时缩放后让图片显示到屏幕中间- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; CGSize originalSize = _scrollview.bounds.size; CGSize contentSize = _scrollview.contentSize; //计算偏移量X轴 CGFloat offSetx = originalSize.width&gt;contentSize.width?(originalSize.width-contentSize.width)/2:0; //计算偏移量Y轴 CGFloat offSetY = originalSize.height&gt;contentSize.height?(originalSize.height-contentSize.height)/2:0; _imageView.center = CGPointMake(contentSize.width/2+offSetx, contentSize.height/2+offSetY);&#125;@end 效果如下图 ​ UIScrollView实战-实现无限循环 说明 如何无限循环一种是无限循环叠加图片，另一种就是如果最后一张图片浏览完立即显示第一张图片。很明显第一种方法是不现实的，使用第二种方式。其实使用第二种方式实现原理比较简单，只要在图片前后各放一张图片即可（此时共有n+2个图片在UIScrollView中）。例如我们有5张图片，只要使用7个UIImageView依次存放：图片5，图片1，图片2，图片3，图片4，图片5，图片1。当从图片1滚动到图片5时由于最后一张是图片1就给用户一种无限循环的感觉，当这张图完全显示后我们迅速将UIScrollView的contentOffset设置到第二个UIImageView，也就是图片1，接着用户可以继续向后滚动。当然向前滚动原理完全一样，当滚动到第一张图片（图片5）就迅速设置UIScrollView的contentOffset显示第6张图（图片5）。 如何优化性能如果图片过多这些图片势必全部加载到内存消耗很大，其实完全没必要创建n+2个UIImageView，其实3个已经足够，只要一直保持显示中间的UIImageView，滚动时动态更改三个UIImageView的图片即可。例如三个UIImageView默认放图片5、图片1、图片2，当前显示中间的UIImageView，也就是图片1,。如果向后滚动那么就会显示图片2，当图片2显示完整后迅速重新设置三个UIImageView的内容为图片1、图片2、图片3，然后通过contentOffset设置显示中间的UIImageView，也就是图片2。继续向后看到图片3，当图片3滚动完成迅速重新设置3个UIImageView的内容为图片2、图片3、图片4，然后设置contentOffset显示中间的UIImageView，也就是图片3。当然，向前滚动原理完全一样，如此就给用户一种循环错觉，而且不占用过多内存。 通过解析plist文件来加载图片数据 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;0.jpg&lt;/key&gt; &lt;string&gt;图0&lt;/string&gt; &lt;key&gt;1.jpg&lt;/key&gt; &lt;string&gt;图1&lt;/string&gt; &lt;key&gt;2.jpg&lt;/key&gt; &lt;string&gt;图2&lt;/string&gt; &lt;key&gt;3.jpg&lt;/key&gt; &lt;string&gt;图3&lt;/string&gt; &lt;key&gt;4.jpg&lt;/key&gt; &lt;string&gt;图4&lt;/string&gt; &lt;key&gt;5.jpg&lt;/key&gt; &lt;string&gt;图5&lt;/string&gt; &lt;key&gt;6.jpg&lt;/key&gt; &lt;string&gt;图6&lt;/string&gt; &lt;key&gt;7.jpg&lt;/key&gt; &lt;string&gt;图7&lt;/string&gt; &lt;key&gt;8.jpg&lt;/key&gt; &lt;string&gt;图8&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//// ViewController.m// 无限滚动图片//// Created by 武 on 18/1/29.// Copyright © 2018年 com. All rights reserved.//#import "ViewController.h"#define SCREEN_WIDTH 320#define SCREEN_HEIGHT 568#define IMAGEVIEW_COUNT 3@interface ViewController ()&lt;UIScrollViewDelegate&gt;&#123; UIScrollView *_scrollView; UIImageView *_leftImageView; UIImageView *_centerImageView; UIImageView *_rightImageView; UIPageControl *_pageControl; UILabel *_label; NSMutableDictionary *_imageData;//图片数据 int _currentImageIndex;//当前图片索引 int _imageCount;//图片总数&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //加载数据 [self loadImageData]; //添加滚动控件 [self addScrollView]; //添加图片控件 [self addImageViews]; //添加分页控件 [self addPageControl]; //添加图片信息描述控件 [self addLabel]; //加载默认图片 [self setDefaultImage];&#125;#pragma mark 加载图片数据- (void)loadImageData&#123; NSString *path = [[NSBundle mainBundle]pathForResource:@"imageInfo" ofType:@"plist"]; _imageData = [NSMutableDictionary dictionaryWithContentsOfFile:path]; _imageCount = _imageData.count;&#125;#pragma mark 添加控件- (void)addScrollView&#123; _scrollView = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].bounds]; [self.view addSubview:_scrollView]; //设置代理 _scrollView.delegate = self; //设置contentSize _scrollView.contentSize = CGSizeMake(IMAGEVIEW_COUNT*SCREEN_WIDTH, SCREEN_HEIGHT); //设置当前显示的位置为中间图片 [_scrollView setContentOffset:CGPointMake(SCREEN_WIDTH, 0) animated:NO]; //设置分页 _scrollView.pagingEnabled=YES; //去掉滚动条 _scrollView.showsHorizontalScrollIndicator=NO;&#125;#pragma mark 添加图片三个控件-(void)addImageViews&#123; _leftImageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _leftImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_leftImageView]; _centerImageView=[[UIImageView alloc]initWithFrame:CGRectMake(SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _centerImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_centerImageView]; _rightImageView=[[UIImageView alloc]initWithFrame:CGRectMake(2*SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _rightImageView.contentMode=UIViewContentModeScaleAspectFit; [_scrollView addSubview:_rightImageView]; &#125;#pragma mark 设置默认显示图片-(void)setDefaultImage&#123; //加载默认图片 _leftImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",_imageCount-1]]; _centerImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",0]]; _rightImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",1]]; _currentImageIndex=0; //设置当前页 _pageControl.currentPage=_currentImageIndex; NSString *imageName=[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]; _label.text=_imageData[imageName];&#125;#pragma mark 添加分页控件-(void)addPageControl&#123; _pageControl=[[UIPageControl alloc]init]; //注意此方法可以根据页数返回UIPageControl合适的大小 CGSize size= [_pageControl sizeForNumberOfPages:_imageCount]; _pageControl.bounds=CGRectMake(0, 0, size.width, size.height); _pageControl.center=CGPointMake(SCREEN_WIDTH/2, SCREEN_HEIGHT-100); //设置颜色 _pageControl.pageIndicatorTintColor=[UIColor colorWithRed:193/255.0 green:219/255.0 blue:249/255.0 alpha:1]; //设置当前页颜色 _pageControl.currentPageIndicatorTintColor=[UIColor colorWithRed:0 green:150/255.0 blue:1 alpha:1]; //设置总页数 _pageControl.numberOfPages=_imageCount; [self.view addSubview:_pageControl];&#125;#pragma mark 添加信息描述控件-(void)addLabel&#123; _label=[[UILabel alloc]initWithFrame:CGRectMake(0, 10, SCREEN_WIDTH,30)]; _label.textAlignment=NSTextAlignmentCenter; _label.textColor=[UIColor colorWithRed:0 green:150/255.0 blue:1 alpha:1]; [self.view addSubview:_label];&#125;#pragma mark 滚动停止事件-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; //重新加载图片 [self reloadImage]; //移动到中间 [_scrollView setContentOffset:CGPointMake(SCREEN_WIDTH, 0) animated:NO]; //设置分页 _pageControl.currentPage=_currentImageIndex; //设置描述 NSString *imageName=[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]; _label.text=_imageData[imageName];&#125;#pragma mark 重新加载图片-(void)reloadImage&#123; int leftImageIndex,rightImageIndex; CGPoint offset=[_scrollView contentOffset]; if (offset.x&gt;SCREEN_WIDTH) &#123; //向右滑动 _currentImageIndex=(_currentImageIndex+1)%_imageCount; &#125;else if(offset.x&lt;SCREEN_WIDTH)&#123; //向左滑动 _currentImageIndex=(_currentImageIndex+_imageCount-1)%_imageCount; &#125; //UIImageView *centerImageView=(UIImageView *)[_scrollView viewWithTag:2]; _centerImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",_currentImageIndex]]; //重新设置左右图片 leftImageIndex=(_currentImageIndex+_imageCount-1)%_imageCount; rightImageIndex=(_currentImageIndex+1)%_imageCount; _leftImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",leftImageIndex]]; _rightImageView.image=[UIImage imageNamed:[NSString stringWithFormat:@"%i.jpg",rightImageIndex]];&#125;@end ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView解析]]></title>
    <url>%2F2018%2F01%2F27%2FUIView%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UIView是管理屏幕上矩形区域内容的对象，iOS中几乎所有UI控件都是UIView的子类。 三个结构体CGPoint、CGSize、CGRect 1.CGPoint 12345struct CGPoint&#123; CGFloat x; //控件x轴位置 CGFLoat y; //控件Y轴位置&#125; CGSize 12345struct CGSize&#123; CGFloat width; //控件宽度 CGFloat height; //控件高度&#125; CGRect 12345struct CGRect&#123; CGPoint origin; //偏移量是相对父视图的 CGSize size;&#125; 视图的基本属性​ frame和center都是相对父视图来说的，bounds是相对自身来说的 frame是相对于父视图左上角原点(0,0)的位置，改变视图的frame会改变center中心点 center是CGPoint值的就是整个视图的中心点，改变视图的center也会改变frame bounds 是CGRect 是告诉子视图本视图的原点位置(通俗的说就是，子视图的frame的origin与父视图的bounds的origin的差，就是子视图相对于父视图左上角的位置，如果结果为负，则子视图在父视图外) 通过addSubview方法添加的子视图，越后添加，越显示到上层。 移除父视图也会把它里面的子视图移除 基本界面元素 1.UIView 1UIView *myView = [[UIView alloc]initWithFrame:CGrectMake(10,10,50,50)];//创建了一个x轴10，y轴10，宽度为50，高度为50的UIView. 2.UIWindow UIWindow继承自UIView，在系统的初始化过程中创建(application didFinishLauchingWithOptions里面) 123self.window = [[[UIWindos alloc]initWithFrame:[UIScreen mainScreen]bounds]autorelease];self.window.backgroundColor = [UIColor grayColor]; //给window设置一个背景色 [self.window makeKeyAndVisible]; //让window显示出来 UIScreen代表了屏幕 12CGRect screenBounds = [ [UIScreen mainScreen]bounds]; //返回的是带有状态栏的Rect CGRect viewBounds = [ [UIScreen mainScreen]applicationFrame]; //不包含状态栏的Rect ​ UIView的方法 一个 UIView 里面可以包含许多的 Subview（其他的 UIView），而这些 Subview 彼此之间是有所谓的阶层关系，这有点类似绘图软体中图层的概念，下面程式码示演示了几个在管理图层（Subview）上常用的方法，其程式码如下。 1.首先是大家最常使用的新增和移除Subview。 ​123[Subview removeFromSuperview]; //将Subview从当前的UIView中移除 [UIView addSubview:Subview]; //UIView增加一个Subview​ 2.在UIView中将Subview往前或是往后移动一个图层，往前移动会覆盖住较后层的 Subview，而往后移动则会被较上层的Subview所覆盖。 123[UIView bringSubviewToFront:Subview]; //将Subview往前移动一个图层（与它的前一个图层对调位置）//将Subview往前移动一个图层（与它的前一个图层对调位置）[UIView sendSubviewToBack:Subview]; //将Subview往后移动一个图层（与它的后一个图层对调位置) 3.在UIView中使用索引Index交换两的Subview彼此的图层层级。 1[UIView exchangeSubviewAtIndex:indexA withSubviewAtIndex:indexB]; //交换两个图层 4.使用Subview的变数名称取得它在UIView中的索引值（Index ） 1NSInteger index = [[UIView subviews] indexOfObject:Subview名称]; //取得Index 5.替Subview加上NSInteger 的註记(Tag)好让之后它们分辨彼此。 12[Subview setTag:NSInteger]; //加上标记 [UIView viewWithTag:NSInteger]; //通过标记得到view 返回值为UIView 6.最后是取得UIView中所有的Subview，呼叫此方法会传回一个 NSArray，并以由后往前的顺序列出这些 Subview，下图中是列出范例图片里Root中所有的Subview。 1[UIView subviews] ; //取的UIView下的所有Subview UIView常用属性和方法 属性 12345678910@property(nonatomic) CGRect frame;//控件的位置和大小，所有的控件必须指定这个属性，否则即使有控件也无法显示@property(nonatomic) CGRect bounds;//当前控件位置和大小，但是和frame不同的是它的位置是确定的(0,0)@property(nonatomic) CGPoint center;//控件的中心位置，一般用户进行控件定位@property(nonatomic) CGAffineTransform transform;//控件矩阵变化，包括平移、缩放、旋转，默认为CGAffineTransformIdentity@property(nonatomic) UIViewAutoresizing autoresizingMask;//控件旋转时大小自动伸缩，默认为UIViewAutoresizingNone@property(nonatomic,readonly) UIView *superview;//当前控件的父控件@property(nonatomic,readonly,copy) NSArray *subviews;//当前控件的子控件返回一个数组@property(nonatomic,getter=isHidden) BOOL hidden;//是否隐藏，默认为不隐藏。@property(nonatomic) UIViewContentMode contentMode; //控件的显示模式。如ImageView的居中模式等@property(nonatomic) NSInteger tag;//控件的标签属性 方法 1234567- (void)addSubview:(UIView *) view;//添加子控件- (void)removeFromSuperView;//从父控件中移除当前控件- (void)insertSubview:(UIView *)view atIndex:(NSInteger) index; //在指定位置插入子控件- (void)beginAnimations:*(NSString *)animationID context:(void *)context;//开始一段动画+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0);//以block的形式执行一段动画，注意这个方法有几种相关的方法- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2); //添加手势操作- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2); //移除手势操作 上面所有位置的属性都是相对于父控件而言（不是相对主屏幕而言） ​]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS程序启动过程]]></title>
    <url>%2F2018%2F01%2F26%2FiOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[点击程序图标打开程序 执行main函数 123456789int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; //第三个参数:UIApplication类名或者子类的名称 nil == @"UIApplication" //第四个参数:UIApplication的代理的代理名称 //NSStringFromClass:把类名转化字符串 //NSStringFromClass好处:1.有提示功能 2.避免输入错误 return UIApplicationMain(argc, argv, nil,NSStringFromClass([AppDelegate class])); &#125;&#125; ​ 执行UIApplicationMain函数 创建UIApplication对象,并设置UIApplicationMain对象的代理. UIApplication的第三个参数就是UIApplication的名称,如果指定为nil,它会默认为UIApplication. UIApplication的第四个参数为UIApplication的代理. 开启监听程序事件 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//程序加载完毕后调用该方法&#125;- (void)applicationWillResignActive:(UIApplication *)application &#123;//程序失去焦点调用该方法&#125;- (void)applicationDidEnterBackground:(UIApplication *)application &#123;//程序进入后台调用该方法&#125;- (void)applicationWillEnterForeground:(UIApplication *)application &#123;//程序从后台将要进入前台调用该方法&#125;- (void)applicationDidBecomeActive:(UIApplication *)application &#123;//内存经过，程序将要停止调用该方法&#125;- (void)applicationWillTerminate:(UIApplication *)application &#123;//程序将要退出调用该方法&#125; 开启一个主运行循环.保证应用程序不退出. 加载info.plist程序配置文件，主要是看我们用的是Storyboard方式加载还是代码的方式加载。(判断一下info.plist文件当中有没有Main storyboard file base name) 通过storyboard方式加载 在程序启动完成的时候系统自动创建一个UIWindow的实例来显示界面 1@property (strong, nonatomic) UIWindow *window; 设置窗口的根控制器 根据storyboard的设置，创建一个控制器。 并且设置这个控制器为之前创建的UIWindow的根控制器 显示窗口。（makeKeyAndVisible） 设置self.window可见并且设置UIApplication的keyWindow 通过代码加载 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *viewController = [[UIViewController alloc] init]; self.window.rootViewController = viewController; [self.window makeKeyAndVisible]; return YES;&#125; ​ 首先创建串口，获取到一个UIWindow实例来显示界面。（self.window为系统自带） 创建一个控制器，将该控制器设置为根控制器 显示窗口[self.window makeKeyAndVisible] 结束程序]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统搭建基于GitHhub的Hexo博客]]></title>
    <url>%2F2018%2F01%2F23%2FMac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHhub%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 注册GitHub帐号 进入GitHub官网注册帐号 创建一个仓库，名称为 yourname.github.io 其中yourname是你的github名称,按照这个规则创建才有用。如你的github注册名称为jack那你创建的仓库名称为jack.github.io 2. 安装node.js 进入nodejs官网下载一步步安装即可,建议安装通用版。 安装完成后可以在终端测试 Node.js 和npm 是否可以使用了。 查看 Node.js 的版本号在终端里输入如下命令：node -v 如果Node.js 成功安装，可以看到类似如下的信息：v6.5.0。查看npm 的版本号在终端里输入如下命令：npm -v如果npm 成功安装，可以看到类似如下的信息：3.10.3。注意命令中间有空格。 3. 安装hexo 可以查看Hexo中文文档 在终端输入 npm install -g hexo-cli 安装 如果Mac系统在安装过程中报错需要安装命令行工具 在终端中输入命令 xcode-select --install会弹出一个窗口选择安装即可。安装完成后输入命令 gcc-v会看到如下信息 Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.5.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin说明安装完成 安装完命令行工具后再输入 $ npm install -g hexo-cli 来安装Hexo，安装完成后输入 hexo 命令会出现下图 4. 初始化博客 新建一个文件夹如我是在文档下新建了一个名称为blog的文件夹名字可以随便取在终端cd到该文件夹 cd Documents/blog/ 然后运行 hexo init命令行，速度取决于网速，可能需要几分钟完成，成功后会在blog目录下生成相关文件，如图 安装完成后运行 hexo s 现在即可在浏览器本地访问 http://localhost:4000/ 会出现下图证明安装成功 5. 关联GitHub 终端 open Documents/blog/ 打开刚才新建的blog文件夹就是我们把hexo init的那个文件夹。打开文件夹下 _config.yml文件,建议使用Sublime Text打开其他文本编辑器也行，滑到最下面修改成如下样子,将我的名字改成你的名字。 注意：在配置所有的_config.yml文件时（包括theme中的）在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 在blog文件夹目录下执行生成静态页面命令：hexo g 然后执行hexo d执行hexo d部署需要你的github用户名和密码 6. 发布文章 终端cd到blog文件夹下运行 hexo new “firstName”名为firstName.md的文件会建在目录/blog/source/_posts下，firstName是文件名.建议使用Mou编辑器。如下图，新建title：为文章名称，date：创建时间，tags:文章所属标签，categories：文章所属分类，注意刚开始新建的文章打开是没有分类的需要修改新建文章模版，打开目录下scaffolds文件夹下的post.md文件在标签上面添加 categories:后续新建文章就会添加分类栏目。 如下图是这篇文章的属性，分类和标签可修改成任意名称，Hexo会自动根据标签和分类归纳文章。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[惯例]]></title>
    <url>%2F2018%2F01%2F18%2Findex%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
  </entry>
</search>
